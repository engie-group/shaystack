<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shaystack API documentation</title>
<meta name="description" content="Implementation of Haystack project https://www.project-haystack.org/
Propose API : â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>shaystack</code></h1>
</header>
<section id="section-intro">
<p>Implementation of Haystack project <a href="https://www.project-haystack.org/">https://www.project-haystack.org/</a>
Propose API :</p>
<ul>
<li>to read or write Haystack file (Zinc, JSon, CSV)</li>
<li>to manipulate ontology in memory (Grid class)</li>
<li>to implement REST API (<a href="https://project-haystack.org/doc/docHaystack/HttpApi">https://project-haystack.org/doc/docHaystack/HttpApi</a>)</li>
<li>to implement GraphQL API</li>
</ul>
<p>With some sample provider:</p>
<ul>
<li>Import ontology on S3 bucket</li>
<li>Import ontology on SQLite or Postgres</li>
<li>and expose the data via Flask or AWS Lambda</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Haystack module
# See the accompanying LICENSE file.
# (C) 2016 VRT Systems
# (C) 2021 Engie Digital
#
# vim: set ts=4 sts=4 et tw=78 sw=4 si:
&#34;&#34;&#34;
Implementation of Haystack project https://www.project-haystack.org/
Propose API :

- to read or write Haystack file (Zinc, JSon, CSV)
- to manipulate ontology in memory (Grid class)
- to implement REST API (https://project-haystack.org/doc/docHaystack/HttpApi)
- to implement GraphQL API

With some sample provider:

- Import ontology on S3 bucket
- Import ontology on SQLite or Postgres
- and expose the data via Flask or AWS Lambda
&#34;&#34;&#34;
from .datatypes import Quantity, Coordinate, Uri, Bin, MARKER, NA, \
    REMOVE, Ref, XStr
from .dumper import dump, dump_scalar
from .grid import Grid
from .grid_filter import parse_filter, parse_hs_datetime_format
from .metadata import MetadataObject
from .ops import *
from .parser import parse, parse_scalar, MODE_HAYSON, MODE_JSON, MODE_TRIO, MODE_ZINC, MODE_CSV, \
    suffix_to_mode, mode_to_suffix
from .pintutil import unit_reg
from .providers import HaystackInterface
from .type import HaystackType, Entity
from .version import Version, VER_2_0, VER_3_0, LATEST_VER

__all__ = [&#39;Grid&#39;, &#39;dump&#39;, &#39;parse&#39;, &#39;dump_scalar&#39;, &#39;parse_scalar&#39;, &#39;parse_filter&#39;,
           &#39;MetadataObject&#39;, &#39;unit_reg&#39;, &#39;zoneinfo&#39;,
           &#39;HaystackType&#39;, &#39;Entity&#39;,
           &#39;Coordinate&#39;, &#39;Uri&#39;, &#39;Bin&#39;, &#39;XStr&#39;, &#39;Quantity&#39;, &#39;MARKER&#39;, &#39;NA&#39;, &#39;REMOVE&#39;, &#39;Ref&#39;,
           &#39;MODE&#39;, &#39;MODE_JSON&#39;, &#39;MODE_HAYSON&#39;, &#39;MODE_ZINC&#39;, &#39;MODE_TRIO&#39;, &#39;MODE_CSV&#39;,
           &#39;suffix_to_mode&#39;, &#39;mode_to_suffix&#39;,
           &#39;parse_hs_datetime_format&#39;,
           &#39;VER_2_0&#39;, &#39;VER_3_0&#39;, &#39;LATEST_VER&#39;, &#39;Version&#39;,

           &#34;HaystackInterface&#34;,
           &#34;about&#34;,
           &#34;ops&#34;,
           &#34;formats&#34;,
           &#34;read&#34;,
           &#34;nav&#34;,
           &#34;watch_sub&#34;,
           &#34;watch_unsub&#34;,
           &#34;watch_poll&#34;,
           &#34;point_write&#34;,
           &#34;his_read&#34;,
           &#34;his_write&#34;,
           &#34;invoke_action&#34;,
           ]

__pdoc__ = {
    &#34;csvdumper&#34;: False,
    &#34;csvparser&#34;: False,
    &#34;datatypes&#34;: False,
    &#34;dumper&#34;: False,
    &#34;filter_ast&#34;: False,
    &#34;grid&#34;: False,
    &#34;grid_diff&#34;: False,
    &#34;grid_filter&#34;: False,
    &#34;jsondumper&#34;: False,
    &#34;jsonparser&#34;: False,
    &#34;metadata&#34;: False,
    &#34;ops&#34;: False,
    &#34;parser&#34;: False,
    &#34;pintutil&#34;: False,
    &#34;sortabledict&#34;: False,
    &#34;triodumper&#34;: False,
    &#34;trioparser&#34;: False,
    &#34;version&#34;: False,
    &#34;zincdumper&#34;: False,
    &#34;zincparser&#34;: False,
    &#34;zoneinfo&#34;: False,
}
__author__ = &#39;Engie Digital, VRT Systems&#39;
__copyright__ = &#39;Copyright 2016-2020, Engie Digital &amp; VRT System&#39;
__credits__ = [&#39;See AUTHORS&#39;]
__license__ = &#39;BSD&#39;
__maintainer__ = &#39;Philippe PRADOS&#39;
__email__ = &#39;shaystack@prados.fr&#39;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="shaystack.empty_grid" href="empty_grid.html">shaystack.empty_grid</a></code></dt>
<dd>
<div class="desc"><p>Read-only Empty grid</p></div>
</dd>
<dt><code class="name"><a title="shaystack.exception" href="exception.html">shaystack.exception</a></code></dt>
<dd>
<div class="desc"><p>Specific exceptions for Haystack API</p></div>
</dd>
<dt><code class="name"><a title="shaystack.haysondumper" href="haysondumper.html">shaystack.haysondumper</a></code></dt>
<dd>
<div class="desc"><p>Save a <code><a title="shaystack.Grid" href="#shaystack.Grid">Grid</a></code> in Hayson file, conform with the specification describe
here (<a href="https://project-haystack.org/forum/topic/792">https://project-haystack.org/forum/topic/792</a>)</p></div>
</dd>
<dt><code class="name"><a title="shaystack.haysonparser" href="haysonparser.html">shaystack.haysonparser</a></code></dt>
<dd>
<div class="desc"><p>Parse Json file conform with the specification describe
here (<a href="https://www.project-haystack.org/doc/Json">https://www.project-haystack.org/doc/Json</a>)
and produce a <code><a title="shaystack.Grid" href="#shaystack.Grid">Grid</a></code> instance.</p></div>
</dd>
<dt><code class="name"><a title="shaystack.period" href="period.html">shaystack.period</a></code></dt>
<dd>
<div class="desc"><p>Generate date period based on period with a start and an end date and return
- All years in this period
- All months in this period
- All days in this â€¦</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers" href="providers/index.html">shaystack.providers</a></code></dt>
<dd>
<div class="desc"><p>Implementation of Haystack API</p></div>
</dd>
<dt><code class="name"><a title="shaystack.tools" href="tools.html">shaystack.tools</a></code></dt>
<dd>
<div class="desc"><p>Tools for all parser and dumper</p></div>
</dd>
<dt><code class="name"><a title="shaystack.type" href="type.html">shaystack.type</a></code></dt>
<dd>
<div class="desc"><p>The typing for Haystack</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="shaystack.MODE"><code class="name flex">
<span>def <span class="ident">MODE</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_type(x):
    return x</code></pre>
</details>
</dd>
<dt id="shaystack.about"><code class="name flex">
<span>def <span class="ident">about</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack about.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def about(envs: Dict[str, str], request: HaystackHttpRequest, stage: str,
          provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack about.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        envs: The environments variables
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers = request.headers
    log.debug(&#34;HAYSTACK_PROVIDER=%s&#34;, envs.get(&#34;HAYSTACK_PROVIDER&#34;, None))
    log.debug(&#34;HAYSTACK_DB=%s&#34;, envs.get(&#34;HAYSTACK_DB&#34;, None))
    try:
        if headers[&#34;Host&#34;].startswith(&#34;localhost:&#34;):
            home = &#34;http://&#34; + headers[&#34;Host&#34;] + &#34;/&#34;
        else:
            home = &#34;https://&#34; + headers[&#34;Host&#34;] + &#34;/&#34; + stage
        grid_response = provider.about(home)
        assert grid_response is not None
        return _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>grid:Â shaystack.grid.Grid, mode:Â ModeÂ =Â 'text/zinc') â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Dump a single grid in the specified over-the-wire format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>The grid to dump.</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>The format. Must be MODE_ZINC, MODE_CSV or MODE_JSON</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(grid: Grid, mode: MODE = MODE_ZINC) -&gt; str:
    &#34;&#34;&#34;
    Dump a single grid in the specified over-the-wire format.
    Args:
        grid: The grid to dump.
        mode: The format. Must be MODE_ZINC, MODE_CSV or MODE_JSON
    &#34;&#34;&#34;
    if mode == MODE_ZINC:
        return dump_zinc_grid(grid)
    if mode == MODE_TRIO:
        return dump_trio_grid(grid)
    if mode == MODE_JSON:
        return dump_json_grid(grid)
    if mode == MODE_HAYSON:
        return dump_hayson_grid(grid)
    if mode == MODE_CSV:
        return dump_csv_grid(grid)
    raise NotImplementedError(&#39;Format not implemented: %s&#39; % mode)</code></pre>
</details>
</dd>
<dt id="shaystack.dump_scalar"><code class="name flex">
<span>def <span class="ident">dump_scalar</span></span>(<span>scalar:Â Any, mode:Â ModeÂ =Â 'text/zinc', version:Â shaystack.version.VersionÂ =Â &lt;shaystack.version.Version object&gt;) â€‘>Â Union[str,Â NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Dump a scalar value in the specified over-the-wire format and version.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scalar</code></strong></dt>
<dd>The value to dump</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>The format. Must be MODE_ZINC, MODE_CSV or MODE_JSON</dd>
<dt><strong><code>version</code></strong></dt>
<dd>The Haystack version to apply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_scalar(scalar: Any, mode: MODE = MODE_ZINC, version: Version = LATEST_VER) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Dump a scalar value in the specified over-the-wire format and version.
    Args:
        scalar: The value to dump
        mode: The format. Must be MODE_ZINC, MODE_CSV or MODE_JSON
        version: The Haystack version to apply
    &#34;&#34;&#34;
    if mode == MODE_ZINC:
        return dump_zinc_scalar(scalar, version=version)
    if mode == MODE_TRIO:
        return dump_trio_scalar(scalar, version=version)
    if mode == MODE_JSON:
        return dump_json_scalar(scalar, version=version)
    if mode == MODE_HAYSON:
        return dump_hayson_scalar(scalar, version=version)
    if mode == MODE_CSV:
        return dump_csv_scalar(scalar, version=version)
    raise NotImplementedError(&#39;Format not implemented: %s&#39; % mode)</code></pre>
</details>
</dd>
<dt id="shaystack.formats"><code class="name flex">
<span>def <span class="ident">formats</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'formats'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats(envs: Dict[str, str], request: HaystackHttpRequest,
            stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;formats&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers = request.headers
    try:
        grid_response = provider.formats()
        if grid_response is None:
            grid_response = Grid(
                version=_DEFAULT_VERSION,
                columns={
                    &#34;mime&#34;: {},
                    &#34;receive&#34;: {},
                    &#34;send&#34;: {},
                },
            )
            grid_response.extend(
                [
                    {
                        &#34;mime&#34;: MODE_ZINC,
                        &#34;receive&#34;: MARKER,
                        &#34;send&#34;: MARKER,
                    },
                    {
                        &#34;mime&#34;: MODE_TRIO,
                        &#34;receive&#34;: MARKER,
                        &#34;send&#34;: MARKER,
                    },
                    {
                        &#34;mime&#34;: MODE_JSON,
                        &#34;receive&#34;: MARKER,
                        &#34;send&#34;: MARKER,
                    },
                    {
                        &#34;mime&#34;: MODE_CSV,
                        &#34;receive&#34;: MARKER,
                        &#34;send&#34;: MARKER,
                    },
                ]
            )
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.his_read"><code class="name flex">
<span>def <span class="ident">his_read</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'hisRead'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def his_read(envs: Dict[str, str], request: HaystackHttpRequest,
             stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;hisRead&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        entity_id = date_version = None
        date_range = None
        default_tz = provider.get_tz()
        if grid_request:
            if &#34;id&#34; in grid_request.column:
                entity_id = grid_request[0].get(&#34;id&#34;, &#34;&#34;)
            if &#34;range&#34; in grid_request.column:
                date_range = grid_request[0].get(&#34;range&#34;, &#34;&#34;)
            date_version = (
                grid_request[0].get(&#34;version&#34;, None) if grid_request else None
            )

        # Priority of query string
        if args:
            if &#34;id&#34; in args:
                entity_id = Ref(args[&#34;id&#34;][1:])
            if &#34;range&#34; in args:
                date_range = args[&#34;range&#34;]
            if &#34;version&#34; in args:
                date_version = parse_hs_datetime_format(args[&#34;version&#34;], default_tz)
                date_version = convert_version(date_version)

        grid_date_range = parse_date_range(date_range, provider.get_tz())
        log.debug(
            &#34;id=%s range=%s, date_version=%s&#34;, entity_id, grid_date_range, date_version
        )
        if date_version:
            if isinstance(date_version, date):
                date_version = datetime.combine(date_version, datetime.max.time()) \
                    .replace(tzinfo=provider.get_tz())
            if grid_date_range[1] &gt; date_version:
                grid_date_range = (grid_date_range[0], date_version)
        grid_response = provider.his_read(entity_id, grid_date_range, date_version)
        assert grid_response is not None
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.his_write"><code class="name flex">
<span>def <span class="ident">his_write</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'hisWrite'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def his_write(envs: Dict[str, str], request: HaystackHttpRequest,
              stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;hisWrite&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        entity_id = grid_request.metadata.get(&#34;id&#34;)
        date_version = grid_request.metadata.get(&#34;version&#34;)
        time_serie_grid = grid_request
        default_tz = provider.get_tz()

        # Priority of query string
        if args:
            if &#34;id&#34; in args:
                entity_id = Ref(args[&#34;id&#34;][1:])
            if &#34;ts&#34; in args:  # Array of tuple
                time_serie_grid = Grid(version=VER_3_0, columns=[&#34;date&#34;, &#34;val&#34;])
                time_serie_grid.extend(
                    [
                        {&#34;date&#34;: parse_hs_datetime_format(d, default_tz), &#34;val&#34;: v}
                        for d, v in literal_eval(args[&#34;ts&#34;])
                    ]
                )
        if &#34;version&#34; in args:
            date_version = parse_hs_datetime_format(args[&#34;version&#34;], default_tz)
        grid_response = provider.his_write(entity_id, time_serie_grid, date_version)
        assert grid_response is not None
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.invoke_action"><code class="name flex">
<span>def <span class="ident">invoke_action</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'invokeAction'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invoke_action(envs: Dict[str, str], request: HaystackHttpRequest,
                  stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;invokeAction&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        entity_id = grid_request.metadata.get(&#34;id&#34;)
        action = grid_request.metadata.get(&#34;action&#34;)
        # Priority of query string
        if args:
            if &#34;id&#34; in args:
                entity_id = Ref(args[&#34;id&#34;][1:])
            if &#34;action&#34; in args:
                action = args[&#34;action&#34;]
        params = grid_request[0] if grid_request else {}
        grid_response = provider.invoke_action(entity_id, action, params)
        assert grid_response is not None
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.mode_to_suffix"><code class="name flex">
<span>def <span class="ident">mode_to_suffix</span></span>(<span>mode:Â Mode) â€‘>Â Union[str,Â NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert haystack mode to file suffix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong></dt>
<dd>The haystack mode (<code>MODE_&hellip;</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The file suffix (<code>.zinc</code>, <code>.json</code>, <code>.trio</code> or <code>.csv</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode_to_suffix(mode: MODE) -&gt; Optional[str]:
    &#34;&#34;&#34;Convert haystack mode to file suffix

    Args:
        mode: The haystack mode (`MODE_...`)
    Returns:
        The file suffix (`.zinc`, `.json`, `.trio` or `.csv`)
    &#34;&#34;&#34;
    return _mode_to_suffix.get(mode, None)</code></pre>
</details>
</dd>
<dt id="shaystack.nav"><code class="name flex">
<span>def <span class="ident">nav</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'nav'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nav(envs: Dict[str, str], request: HaystackHttpRequest, stage: str,
        provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;nav&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        nav_id = None
        if grid_request and &#34;navId&#34; in grid_request.column:
            nav_id = grid_request[0][&#34;navId&#34;]
        if args and &#34;navId&#34; in args:
            nav_id = args[&#34;navId&#34;]
        grid_response = provider.nav(nav_id=nav_id)
        assert grid_response is not None
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>grid_str:Â str, mode:Â ModeÂ =Â 'text/zinc') â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_str</code></strong></dt>
<dd>The string to parse</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>The format (<code>MODE_&hellip;</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(grid_str: str, mode: MODE = MODE_ZINC) -&gt; Grid:
    # Decode incoming text
    &#34;&#34;&#34;
    Parse a grid.
    Args:
        grid_str: The string to parse
        mode: The format (`MODE_...`)
    Returns:
        a grid
    &#34;&#34;&#34;
    if isinstance(grid_str, bytes):  # pragma: no cover
        # No coverage here, because it *should* be handled above unless the user
        # is preempting us by calling `parse_grid` directly.
        if grid_str[:2] == b&#39;\xef\xbb&#39;:
            grid_str = grid_str.decode(encoding=&#34;utf-8-sig&#34;)
        else:
            grid_str = grid_str.decode(encoding=&#34;utf-8&#34;)

    if grid_str and grid_str[-1] not in [&#39;\n&#39;, &#39;\r&#39;]:
        grid_str += &#39;\n&#39;

    if mode == MODE_ZINC:
        return parse_zinc_grid(grid_str)
    if mode == MODE_TRIO:
        return parse_trio_grid(grid_str)
    if mode == MODE_JSON:
        return parse_json_grid(grid_str)
    if mode == MODE_HAYSON:
        return parse_hayson_grid(grid_str)
    if mode == MODE_CSV:
        return parse_csv_grid(grid_str)
    raise NotImplementedError(&#39;Format not implemented: %s&#39; % mode)</code></pre>
</details>
</dd>
<dt id="shaystack.parse_filter"><code class="name flex">
<span>def <span class="ident">parse_filter</span></span>(<span>grid_filter:Â str) â€‘>Â shaystack.filter_ast.FilterAST</span>
</code></dt>
<dd>
<div class="desc"><p>Return an AST tree of filter. Can be used to generate other language
(Python, SQL, etc.)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_filter</code></strong></dt>
<dd>A filter request</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>FilterAST</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_filter(grid_filter: str) -&gt; FilterAST:
    &#34;&#34;&#34;Return an AST tree of filter. Can be used to generate other language
    (Python, SQL, etc.)

    Args:
        grid_filter: A filter request
    Returns:
        A `FilterAST`
    &#34;&#34;&#34;
    with pyparser_lock:
        return FilterAST(hs_filter.parseString(grid_filter, parseAll=True)[0])</code></pre>
</details>
</dd>
<dt id="shaystack.parse_hs_datetime_format"><code class="name flex">
<span>def <span class="ident">parse_hs_datetime_format</span></span>(<span>datetime_str:Â str, timezone:Â datetime.tzinfo) â€‘>Â datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the haystack date time (for filter).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>datetime_str</code></strong></dt>
<dd>The string to parse</dd>
<dt><strong><code>timezone</code></strong></dt>
<dd>Time zone info</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the corresponding <code>datetime</code></p>
<h2 id="raises">Raises</h2>
<p><code>pyparsing.ParseException</code> if the string does not conform</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_hs_datetime_format(datetime_str: str, timezone: tzinfo) -&gt; datetime:
    &#34;&#34;&#34;
    Parse the haystack date time (for filter).
    Args:
        datetime_str: The string to parse
        timezone: Time zone info
    Returns:
        the corresponding `datetime`
    Raises:
        `pyparsing.ParseException` if the string does not conform
    &#34;&#34;&#34;
    if datetime_str == &#34;today&#34;:
        return datetime.combine(date.today(), datetime.min.time()) \
            .replace(tzinfo=timezone)
    if datetime_str == &#34;yesterday&#34;:
        return datetime.combine(date.today() - timedelta(days=1), datetime.min.time()) \
            .replace(tzinfo=timezone)

    return hs_all_date.parseString(datetime_str, parseAll=True)[0]</code></pre>
</details>
</dd>
<dt id="shaystack.parse_scalar"><code class="name flex">
<span>def <span class="ident">parse_scalar</span></span>(<span>scalar:Â Union[bytes,Â str,Â dict], mode:Â ModeÂ =Â 'text/zinc', version:Â Union[shaystack.version.Version,Â str]Â =Â &lt;shaystack.version.Version object&gt;) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a scalar value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scalar</code></strong></dt>
<dd>The scalar data to parse</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>The haystack mode</dd>
<dt><strong><code>version</code></strong></dt>
<dd>The haystack version</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_scalar(scalar: Union[bytes, str, dict], mode: MODE = MODE_ZINC,
                 version: Union[Version, str] = LATEST_VER) -&gt; Any:
    # Decode version string
    &#34;&#34;&#34;
    Parse a scalar value
    Args:
        scalar: The scalar data to parse
        mode: The haystack mode
        version: The haystack version
    Returns:
        a value
    &#34;&#34;&#34;
    charset = &#39;utf-8&#39;
    if not isinstance(version, Version):
        version = Version(version)

    # Decode incoming text
    if isinstance(scalar, bytes):
        scalar = scalar.decode(encoding=charset)

    if mode == MODE_ZINC:
        return parse_zinc_scalar(scalar, version=version)
    if mode == MODE_TRIO:
        return parse_trio_scalar(scalar, version=version)
    if mode == MODE_JSON:
        return parse_json_scalar(scalar, version=version)
    if mode == MODE_CSV:
        return parse_csv_scalar(scalar, version=version)
    if mode == MODE_HAYSON:
        return parse_hayson_scalar(scalar, version=version)

    raise NotImplementedError(&#39;Format not implemented: %s&#39; % mode)</code></pre>
</details>
</dd>
<dt id="shaystack.point_write"><code class="name flex">
<span>def <span class="ident">point_write</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'pointWrite'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_write(envs: Dict[str, str], request: HaystackHttpRequest,
                stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;pointWrite&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        date_version = None
        level = 17
        val = who = duration = None
        entity_id = None
        default_tz = provider.get_tz()
        if grid_request:
            entity_id = grid_request[0][&#34;id&#34;]
            date_version = grid_request[0].get(&#34;version&#34;, None)
            if &#34;level&#34; in grid_request[0]:
                level = int(grid_request[0][&#34;level&#34;])
            val = grid_request[0].get(&#34;val&#34;)
            who = grid_request[0].get(&#34;who&#34;)
            duration = grid_request[0].get(&#34;duration&#34;)  # Must be quantity

        if &#34;id&#34; in args:
            entity_id = Ref(args[&#34;id&#34;][1:])
        if &#34;level&#34; in args:
            level = int(args[&#34;level&#34;])
        if &#34;val&#34; in args:
            val = parse_scalar(
                args[&#34;val&#34;],
                mode=MODE_ZINC,
            )
        if &#34;who&#34; in args:
            val = args[&#34;who&#34;]
        if &#34;duration&#34; in args:
            duration = parse_scalar(args[&#34;duration&#34;])
            assert isinstance(duration, Quantity)
        if &#34;version&#34; in args:
            date_version = parse_hs_datetime_format(args[&#34;version&#34;], default_tz)
        if entity_id is None:
            raise ValueError(&#34;&#39;id&#39; must be set&#34;)
        if val is not None:
            provider.point_write_write(
                entity_id, level, val, who, duration, date_version
            )
            grid_response = EmptyGrid
        else:
            grid_response = provider.point_write_read(entity_id, date_version)
            assert grid_response is not None
            assert &#34;level&#34; in grid_response.column
            assert &#34;levelDis&#34; in grid_response.column
            assert &#34;val&#34; in grid_response.column
            assert &#34;who&#34; in grid_response.column
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack <code><a title="shaystack.read" href="#shaystack.read">read()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(envs: Dict[str, str], request: HaystackHttpRequest, stage: str,
         provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack `read`
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        read_ids: Optional[List[Ref]] = None
        select = read_filter = date_version = None
        limit = 0
        default_tz = provider.get_tz()
        if grid_request:
            if &#34;id&#34; in grid_request.column:
                read_ids = [row[&#34;id&#34;] for row in grid_request]
            else:
                if &#34;filter&#34; in grid_request.column:
                    read_filter = grid_request[0].get(&#34;filter&#34;, &#34;&#34;)
                else:
                    read_filter = &#34;&#34;
                if &#34;limit&#34; in grid_request.column:
                    limit = int(grid_request[0].get(&#34;limit&#34;, 0))
            if &#34;select&#34; in grid_request.column:
                select = grid_request[0].get(&#34;select&#34;, &#34;*&#34;)
            date_version = (
                grid_request[0].get(&#34;version&#34;, None) if grid_request else None
            )
        # Priority of query string
        if args:
            if &#34;id&#34; in args:
                read_ids = [Ref(entity_id) for entity_id in args[&#34;id&#34;].split(&#34;,&#34;)]
            else:
                if &#34;filter&#34; in args:
                    read_filter = args[&#34;filter&#34;]
                if &#34;limit&#34; in args:
                    limit = int(args[&#34;limit&#34;])
            if &#34;select&#34; in args:
                select = args[&#34;select&#34;]
            if &#34;version&#34; in args:
                date_version = parse_hs_datetime_format(args[&#34;version&#34;], default_tz)
                date_version = convert_version(date_version)
        if read_filter is None:
            read_filter = &#34;&#34;
        if read_ids is None and read_filter is None:
            raise ValueError(&#34;&#39;id&#39; or &#39;filter&#39; must be set&#34;)
        log.debug(
            &#34;id=%s select=&#39;%s&#39; filter=&#39;%s&#39; limit=%s, date_version=%s&#34;,
            read_ids,
            select,
            read_filter,
            limit,
            date_version,
        )
        grid_response = provider.read(limit, select, read_ids, read_filter, date_version)
        assert grid_response is not None
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.suffix_to_mode"><code class="name flex">
<span>def <span class="ident">suffix_to_mode</span></span>(<span>ext:Â str) â€‘>Â Union[Mode,Â NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a file suffix to Haystack mode</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ext</code></strong></dt>
<dd>The file suffix (<code>.zinc</code>, <code>.json</code>, <code>.trio</code> or <code>.csv</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The corresponding haystack mode (<code>MODE_&hellip;</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suffix_to_mode(ext: str) -&gt; Optional[MODE]:
    &#34;&#34;&#34;Convert a file suffix to Haystack mode

    Args:
        ext: The file suffix (`.zinc`, `.json`, `.trio` or `.csv`)
    Returns:
        The corresponding haystack mode (`MODE_...`)
    &#34;&#34;&#34;
    return cast(Optional[MODE], _suffix_to_mode.get(ext, None))</code></pre>
</details>
</dd>
<dt id="shaystack.watch_poll"><code class="name flex">
<span>def <span class="ident">watch_poll</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'watchPoll'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_poll(envs: Dict[str, str], request: HaystackHttpRequest,
               stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;watchPoll&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        watch_id = None
        refresh = False
        if grid_request:
            if &#34;watchId&#34; in grid_request.metadata:
                watch_id = grid_request.metadata[&#34;watchId&#34;]
            if &#34;refresh&#34; in grid_request.metadata:
                refresh = True
        if args:
            if &#34;watchId&#34; in args:
                watch_id = args[&#34;watchId&#34;]
            if &#34;refresh&#34; in args:
                refresh = True

        grid_response = provider.watch_poll(watch_id, refresh)
        assert grid_response is not None
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.watch_sub"><code class="name flex">
<span>def <span class="ident">watch_sub</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'watchSub'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_sub(envs: Dict[str, str], request: HaystackHttpRequest,
              stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;watchSub&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        watch_dis = watch_id = lease = None
        ids = []
        if grid_request:
            watch_dis = grid_request.metadata[&#34;watchDis&#34;]
            watch_id = grid_request.metadata.get(&#34;watchId&#34;, None)
            if &#34;lease&#34; in grid_request.metadata:
                lease = int(grid_request.metadata[&#34;lease&#34;])
            ids = [row[&#34;id&#34;] for row in grid_request]

        if args:
            if &#34;watchDis&#34; in args:
                watch_dis = args[&#34;watchDis&#34;]
            if &#34;watchId&#34; in args:
                watch_id = args[&#34;watchId&#34;]
            if &#34;lease&#34; in args:
                lease = int(args[&#34;lease&#34;])
            if &#34;ids&#34; in args:  # Use list of str
                ids = [Ref(x[1:]) for x in literal_eval(args[&#34;ids&#34;])]
        if not watch_dis:
            raise ValueError(&#34;&#39;watchDis&#39; and &#39;watchId&#39; must be setted&#34;)
        grid_response = provider.watch_sub(watch_dis, watch_id, ids, lease)
        assert grid_response is not None
        assert &#34;watchId&#34; in grid_response.metadata
        assert &#34;lease&#34; in grid_response.metadata
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
<dt id="shaystack.watch_unsub"><code class="name flex">
<span>def <span class="ident">watch_unsub</span></span>(<span>envs:Â Dict[str,Â str], request:Â shaystack.ops.HaystackHttpRequest, stage:Â str, provider:Â <a title="shaystack.providers.haystack_interface.HaystackInterface" href="providers/haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a>) â€‘>Â shaystack.ops.HaystackHttpResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'watchUnsub'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>envs</code></strong></dt>
<dd>The environments variables</dd>
<dt><strong><code>provider</code></strong></dt>
<dd>HaystackInterface provider to be used</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The HTTP Request</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>The current stage (<code>prod</code>, <code>dev</code>, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTTP Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_unsub(envs: Dict[str, str], request: HaystackHttpRequest,
                stage: str, provider: HaystackInterface) -&gt; HaystackHttpResponse:
    &#34;&#34;&#34;
    Implement Haystack &#39;watchUnsub&#39;.
    Args:
        envs: The environments variables
        provider: HaystackInterface provider to be used
        request: The HTTP Request
        stage: The current stage (`prod`, `dev`, etc.)

    Returns:
        The HTTP Response
    &#34;&#34;&#34;
    headers, args = (request.headers, request.args)
    try:
        grid_request = _parse_body(request)
        close = False
        watch_id = False
        ids = []
        if grid_request:
            if &#34;watchId&#34; in grid_request.metadata:
                watch_id = grid_request.metadata[&#34;watchId&#34;]
            if &#34;close&#34; in grid_request.metadata:
                close = bool(grid_request.metadata[&#34;close&#34;])
            ids = [row[&#34;id&#34;] for row in grid_request]

        if args:
            if &#34;watchId&#34; in args:
                watch_id = args[&#34;watchId&#34;]
            if &#34;close&#34; in args:
                close = bool(args[&#34;close&#34;])
            if &#34;ids&#34; in args:  # Use list of str
                ids = {Ref(x[1:]) for x in literal_eval(args[&#34;ids&#34;])}

        if not watch_id:
            raise ValueError(&#34;&#39;watchId&#39; must be set&#34;)
        provider.watch_unsub(watch_id, ids, close)
        grid_response = EmptyGrid
        response = _format_response(headers, grid_response, 200, &#34;OK&#34;)
    except Exception as ex:  # pylint: disable=broad-except
        response = _manage_exception(headers, ex, stage)
    return response</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shaystack.Bin"><code class="flex name class">
<span>class <span class="ident">Bin</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>A convenience class to allow identification of a Bin from other string
types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bin(str):
    &#34;&#34;&#34;A convenience class to allow identification of a Bin from other string
    types.
    &#34;&#34;&#34;

    def __repr__(self) -&gt; str:
        return &#39;%s(%s)&#39; % (self.__class__.__name__,
                           super().__repr__())

    def __eq__(self, other: &#39;Bin&#39;) -&gt; bool:
        assert isinstance(other, Bin)
        return super().__eq__(other)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
</dd>
<dt id="shaystack.Coordinate"><code class="flex name class">
<span>class <span class="ident">Coordinate</span></span>
<span>(</span><span>latitude:Â float, longitude:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>A 2D co-ordinate in degrees latitude and longitude.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>latitude</code></strong></dt>
<dd>the latitude</dd>
<dt><strong><code>longitude</code></strong></dt>
<dd>the longitude</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Coordinate:
    &#34;&#34;&#34;A 2D co-ordinate in degrees latitude and longitude.
        Args:
            latitude: the latitude
            longitude: the longitude
    &#34;&#34;&#34;
    __slots__ = &#34;latitude&#34;, &#34;longitude&#34;

    def __init__(self, latitude: float, longitude: float):
        self.latitude = latitude
        self.longitude = longitude

    def __repr__(self) -&gt; str:
        return &#39;%s(%r, %r)&#39; % (
            self.__class__.__name__, self.latitude, self.longitude
        )

    def __str__(self) -&gt; str:
        return (&#39;%f\N{DEGREE SIGN} lat %f\N{DEGREE SIGN} long&#39; % (
            round(self.latitude, ndigits=6), round(self.longitude, ndigits=6)
        ))

    def __eq__(self, other: &#39;Coordinate&#39;) -&gt; bool:
        if not isinstance(other, Coordinate):
            return False
        return (self.latitude == other.latitude) and \
               (self.longitude == other.longitude)

    def __ne__(self, other: &#39;Coordinate&#39;) -&gt; bool:
        if not isinstance(other, Coordinate):
            return True
        return not self == other

    def __hash__(self) -&gt; int:
        return hash(self.latitude) ^ hash(self.longitude)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="shaystack.Coordinate.latitude"><code class="name">var <span class="ident">latitude</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="shaystack.Coordinate.longitude"><code class="name">var <span class="ident">longitude</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="shaystack.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>version:Â Union[str,Â shaystack.version.Version,Â NoneType]Â =Â None, metadata:Â Union[NoneType,Â Dict[str,Â Union[str,Â int,Â float,Â bool,Â datetime.date,Â datetime.time,Â datetime.datetime,Â shaystack.datatypes.Ref,Â shaystack.datatypes.Quantity,Â shaystack.datatypes.Coordinate,Â shaystack.datatypes.Uri,Â shaystack.datatypes.Bin,Â shaystack.datatypes.XStr,Â shaystack.datatypes._MarkerType,Â shaystack.datatypes._NAType,Â shaystack.datatypes._RemoveType,Â List[Any],Â Dict[str,Â Any],Â NoneType]],Â shaystack.metadata.MetadataObject,Â shaystack.sortabledict.SortableDict]Â =Â None, columns:Â Union[shaystack.sortabledict.SortableDict,Â Dict[str,Â Union[str,Â int,Â float,Â bool,Â datetime.date,Â datetime.time,Â datetime.datetime,Â shaystack.datatypes.Ref,Â shaystack.datatypes.Quantity,Â shaystack.datatypes.Coordinate,Â shaystack.datatypes.Uri,Â shaystack.datatypes.Bin,Â shaystack.datatypes.XStr,Â shaystack.datatypes._MarkerType,Â shaystack.datatypes._NAType,Â shaystack.datatypes._RemoveType,Â List[Any],Â Dict[str,Â Any],Â NoneType]],Â Iterable[Union[Tuple[str,Â Any],Â str]],Â NoneType]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A grid is basically a series of tabular records. The grid has a header
which describes some metadata about the grid and its columns. This is
followed by zero or more rows.</p>
<p>The grid propose different standard operator.</p>
<ul>
<li>It's possible to access an entity with the position in the grid: <code>grid[1]</code></li>
<li>or if the entity has an <code>id</code>, with this <code>id</code>: <code>grid[Ref("abc")]</code></li>
<li>To extract a portion of grid, use a slice: <code>grid[10:12]</code></li>
<li>To check if a specific <code>id</code> is in the grid: <code>Ref("abc") in grid</code></li>
<li>To calculate the difference between grid: <code>grid_v2 - grid_v1</code></li>
<li>To merge two grid: <code>grid_a + grid_b</code></li>
<li>To compare a grid: <code>grid_v1 + (grid_v2 - grid_v1) == grid_v2</code></li>
<li>Size of grid: <code>len(grid)</code></li>
<li>Replace an entity with <code>id</code>: <code>grid[Ref("abc")] = new_entity</code></li>
<li>Replace a group of entities: <code>grid[2:3] = [new_entity1,new_entity2]</code></li>
<li>Delete an entity with <code>id</code>: <code>del grid[Ref("abc")]</code></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>version</code></strong></dt>
<dd>The haystack version (See VERSION_&hellip;)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>A dictionary with the metadata associated with the grid.</dd>
<dt><strong><code>columns</code></strong></dt>
<dd>A list of columns, or a dictionary with columns name and corresponding metadata</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid(MutableSequence):  # pytlint: disable=too-many-ancestors
    &#34;&#34;&#34;A grid is basically a series of tabular records. The grid has a header
    which describes some metadata about the grid and its columns. This is
    followed by zero or more rows.

    The grid propose different standard operator.

    - It&#39;s possible to access an entity with the position in the grid: `grid[1]`
    - or if the entity has an `id`, with this `id`: `grid[Ref(&#34;abc&#34;)]`
    - To extract a portion of grid, use a slice: `grid[10:12]`
    - To check if a specific `id` is in the grid: `Ref(&#34;abc&#34;) in grid`
    - To calculate the difference between grid: `grid_v2 - grid_v1`
    - To merge two grid: `grid_a + grid_b`
    - To compare a grid: `grid_v1 + (grid_v2 - grid_v1) == grid_v2`
    - Size of grid: `len(grid)`
    - Replace an entity with `id`: `grid[Ref(&#34;abc&#34;)] = new_entity`
    - Replace a group of entities: `grid[2:3] = [new_entity1,new_entity2]`
    - Delete an entity with `id`: `del grid[Ref(&#34;abc&#34;)]`

    Args:
        version: The haystack version (See VERSION_...)
        metadata: A dictionary with the metadata associated with the grid.
        columns: A list of columns, or a dictionary with columns name and corresponding metadata
    &#34;&#34;&#34;

    __slots__ = &#34;_version&#34;, &#34;_version_given&#34;, &#34;metadata&#34;, &#34;column&#34;, &#34;_row&#34;, &#34;_index&#34;

    def __init__(self,
                 version: Union[str, Version, None] = None,
                 metadata: Union[None, Entity, MetadataObject, SortableDict] = None,
                 columns: Union[SortableDict,
                                Entity,
                                Iterable[Union[Tuple[str, Any], str]],
                                None] = None):
        version_given = version is not None
        if version_given:
            version = Version(version)
        else:
            version = VER_3_0
        self._version = version
        self._version_given = version_given

        # Metadata
        self.metadata = MetadataObject(validate_fn=self._detect_or_validate)

        # The columns
        self.column = SortableDict()

        # Rows
        self._row: List[Entity] = []

        # Internal index
        self._index: Optional[Dict[Ref, Entity]] = None

        if metadata is not None:
            self.metadata.update(metadata.items())

        if columns is not None:
            if isinstance(columns, (dict, SortableDict)):
                columns = list(columns.items())
            elif isinstance(columns, Sequence) and columns and not isinstance(columns[0], tuple):
                columns = list(zip(columns, [{}] * len(columns)))

            for col_id, col_meta in columns:
                # Convert sorted lists and dicts back to a list of items.
                if isinstance(col_meta, (dict, SortableDict)):
                    col_meta = list(col_meta.items())

                metadata_object = MetadataObject(validate_fn=self._detect_or_validate)
                metadata_object.extend(col_meta)
                self.column.add_item(col_id, metadata_object)

    # noinspection PyArgumentList
    @staticmethod
    def _approx_check(version_1: Any, version_2: Any) -&gt; bool:
        &#34;&#34;&#34;
        Compare two values with a tolerance

        Args:
            version_1: value one
            version_2: value two
        Returns:
            true if the values are approximately identical
        &#34;&#34;&#34;
        if isinstance(version_1, numbers.Number) and isinstance(version_2, numbers.Number):
            # noinspection PyUnresolvedReferences
            return abs(version_1 - version_2) &lt; 0.000001
        # pylint: disable=C0123
        if type(version_1) != type(version_2) and \
                not (isinstance(version_1, str) and isinstance(version_2, str)):
            return False
        # pylint: enable=C0123
        if isinstance(version_1, datetime.time) and isinstance(version_2, datetime.time):
            # noinspection PyArgumentList
            return version_1.replace(microsecond=0) == version_2.replace(microsecond=0)
        if isinstance(version_1, datetime.datetime) and isinstance(version_2, datetime.datetime):
            dt1, dt2 = version_1.replace(tzinfo=pytz.UTC), version_2.replace(tzinfo=pytz.UTC)
            return dt1.date() == dt2.date() and Grid._approx_check(dt1.time(), dt2.time())
        if isinstance(version_1, Quantity) and isinstance(version_2, Quantity):
            return version_1.units == version_2.units and \
                   Grid._approx_check(version_1.m, version_2.m)
        if isinstance(version_1, Coordinate) and isinstance(version_2, Coordinate):
            return Grid._approx_check(version_1.latitude, version_2.latitude) and \
                   Grid._approx_check(version_1.longitude, version_2.longitude)
        if isinstance(version_1, dict) and isinstance(version_2, dict):
            for key, val in version_1.items():
                if not Grid._approx_check(val, version_2.get(key, None)):
                    return False
            for key, val in version_2.items():
                if key not in version_1 and not Grid._approx_check(version_1.get(key, None), val):
                    return False
            return True
        return version_1 == version_2

    def __eq__(self, other: &#39;Grid&#39;) -&gt; bool:
        &#34;&#34;&#34;
        Campare two grid with tolerance.
        Args:
            other: Other grid
        Returns:
            true if equals
        &#34;&#34;&#34;
        if not isinstance(other, Grid):
            return False
        if set(self.metadata.keys()) != set(other.metadata.keys()):
            return False
        for key in self.metadata.keys():
            if not Grid._approx_check(self.metadata[key], other.metadata[key]):
                return False
        # Check column matches
        if set(self.column.keys()) != set(other.column.keys()):
            return False

        for col_name in self.column.keys():
            if col_name not in other.column or \
                    len(self.column[col_name]) != len(other.column[col_name]):
                return False
            for key in self.column[col_name].keys():
                if not Grid._approx_check(self.column[col_name][key], other.column[col_name][key]):
                    return False
        # Check row matches
        if len(self) != len(other):
            return False

        pending_right_row = [id(row) for row in other if &#39;id&#39; not in row]
        for left in self._row:
            # Search record in other with same values
            find = False
            if &#39;id&#39; in left:
                if left[&#39;id&#39;] in other and self._approx_check(left, other[left[&#39;id&#39;]]):
                    find = True
            else:
                for right in other._row:
                    if id(right) not in pending_right_row:
                        continue
                    if self._approx_check(left, right):
                        find = True
                        pending_right_row.remove(id(right))
                        break
            if not find:
                return False

        return True

    def __sub__(self, other: &#39;Grid&#39;) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;Calculate the difference between two grid. The result is a grid with
        only the attributs to update (change value, delete, etc) If a row with
        id must be removed, - if the row has an id, the result add a row with
        this id, and a tag &#39;remove_&#39; - if the row has not an id, the result add
        a row with all values of the original row, and a tag &#39;remove_&#39;

        It&#39;s possible to update all metadatas, the order of columns, add,
        remove or update some rows

        It&#39;s possible to apply the result in a grid, with the add operator.
        At all time, with gridA and gridB, gridA + (gridB - gridA) == gridB

        Args:
            other: grid to substract
        Returns:
            Only the difference between grid.
        &#34;&#34;&#34;
        assert isinstance(other, Grid)
        from .grid_diff import grid_diff  # pylint: disable: import-outside-toplevel
        return grid_diff(other, self)

    def __add__(self, other: &#39;Grid&#39;) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;Merge two grids. The metadata can be modified with the values from
        other. Some attributs can be removed if the `other` attributs is REMOVE.
        If a row have a &#39;remove_&#39; tag, the corresponding row was removed.

        The result of __sub__() can be used to patch the current grid. At all
        time, with `gridA` and `gridB`, `gridA + (gridB - gridA) == gridB`

        Args:
            other: List of entities to updates
        Returns:
            A new grid
        &#34;&#34;&#34;
        assert isinstance(other, Grid)
        from .grid_diff import grid_merge  # pylint: disable: import-outside-toplevel
        if &#39;diff_&#39; in self.metadata:
            return grid_merge(other.copy(), self)
        return grid_merge(self.copy(), other)

    def __repr__(self) -&gt; str:  # pragma: no cover
        &#34;&#34;&#34;Return a representation of this grid.&#34;&#34;&#34;
        parts = [&#39;\tVersion: %s&#39; % str(self.version)]
        if bool(self.metadata):
            parts.append(&#39;\tMetadata: %s&#39; % self.metadata)

        column_meta = []
        for col_name, col_meta in self.column.items():
            if bool(col_meta):
                column_meta.append(&#39;\t\t%s: %s&#39; % (col_name, col_meta))
            else:
                column_meta.append(&#39;\t\t%s&#39; % col_name)

        if bool(column_meta):
            parts.append(&#39;\tColumns:\n%s&#39; % &#39;\n&#39;.join(column_meta))
        elif self.column:
            parts.append(&#39;\tColumns: %s&#39; % &#39;, &#39;.join(self.column.keys()))
        else:
            parts.append(&#39;\tNo columns&#39;)

        if bool(self):
            parts.extend([
                &#39;\t---- Row %4d:\n\t%s&#39; % (row, &#39;\n\t&#39;.join([
                    ((&#39;%s=%r&#39; % (col_name, data[col_name]))
                     if col_name in data else
                     (&#39;%s absent&#39; % col_name)) for col_name in self.column.keys()]))
                for (row, data) in enumerate(self)
            ])
        else:
            parts.append(&#39;\tNo rows&#39;)
        class_name = self.__class__.__name__
        return &#39;%s\n%s\n&#39; % (
            class_name, &#39;\n&#39;.join(parts)
        )

    def __getitem__(self, key: Union[int, Ref, slice]) -&gt; Union[Entity, &#39;Grid&#39;]:
        &#34;&#34;&#34;Retrieve the row at index. :param key: index, Haystack reference or
        slice

        Args:
            key: the position, the Reference or a slice

        Returns:
            The entity of an new grid with a portion of entities, with the same metadata and columns
        &#34;&#34;&#34;
        if isinstance(key, int):
            return cast(Entity, self._row[key])
        if isinstance(key, slice):
            result = Grid(version=self.version, metadata=self.metadata, columns=self.column)
            result._row = self._row[key]
            result._index = None
            return result
        assert isinstance(key, Ref), &#34;The &#39;key&#39; must be a Ref or int&#34;
        if not self._index:
            self.reindex()
        return cast(Entity, self._index[key])

    def __contains__(self, key: Union[int, Ref]) -&gt; bool:
        &#34;&#34;&#34;Return an entity with the corresponding id.

        Args:
            key: The position of id of entity

        Returns:
            &#39;True&#39; if the referenced entity is present
        &#34;&#34;&#34;
        if isinstance(key, int):
            return 0 &lt;= key &lt; len(self._row)
        if not self._index:
            self.reindex()
        return key in self._index

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of rows in the grid.&#34;&#34;&#34;
        return len(self._row)

    def __setitem__(self, index: Union[int, Ref, slice], value: Union[Entity, List[Entity]]) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;Replace the row at index.

        Args:
            index: position of reference, reference of slice
            value: the new entity
        Returns:
            `self`
        &#34;&#34;&#34;
        if isinstance(value, dict):
            for val in value.values():
                self._detect_or_validate(val)
        if isinstance(index, int):
            if not isinstance(value, dict):
                raise TypeError(&#39;value must be a dict&#39;)
            if &#34;id&#34; in self._row[index]:
                self._index.pop(self._row[index][&#39;id&#39;], None)
            self._row[index] = value
            if &#34;id&#34; in value:
                self._index[value[&#34;id&#34;]] = value
        elif isinstance(index, slice):
            if isinstance(value, dict):
                raise TypeError(&#39;value must be iterable, not a dict&#39;)
            self._index = None
            self._row[index] = value
            for row in value:
                for val in row.values():
                    self._detect_or_validate(val)
        else:
            if not isinstance(value, dict):
                raise TypeError(&#39;value must be a dict&#39;)
            if not self._index:
                self.reindex()
            idx = list.index(self._row, self._index[index])
            if &#34;id&#34; in self._row[idx]:
                self._index.pop(self._row[idx][&#39;id&#39;], None)
            self._row[idx] = value
            if &#34;id&#34; in value:
                self._index[value[&#34;id&#34;]] = value
        return self

    def __delitem__(self, key: Union[int, Ref]) -&gt; Optional[Entity]:
        &#34;&#34;&#34;Delete the row at index.

        Args:
            key: The key to find the corresponding entity
        Returns:
            The entity or `None`
        &#34;&#34;&#34;
        return self.pop(key)

    def clear(self):
        self._row = []
        self._index = None

    @property
    def version(self) -&gt; Version:  # pragma: no cover
        &#34;&#34;&#34; The haystack version of grid &#34;&#34;&#34;
        return self._version

    @property
    def nearest_version(self) -&gt; Version:  # pragma: no cover
        &#34;&#34;&#34; The nearest haystack version of grid &#34;&#34;&#34;
        return Version.nearest(self._version)

    def get(self, index: Ref, default: Optional[Entity] = None) -&gt; Entity:
        &#34;&#34;&#34;Return an entity with the corresponding id.

        Args:
            index: The id of entity
            default: The default value if the entity is not found

        Returns:
            The entity with the id == index or the default value
        &#34;&#34;&#34;
        if not self._index:
            self.reindex()
        return cast(Entity, self._index.get(index, default))

    def keys(self) -&gt; KeysView[Ref]:
        &#34;&#34;&#34; Return the list of ids of entities with `id`

        Returns:
             The list of ids of entities with `id`
        &#34;&#34;&#34;
        if not self._index:
            self.reindex()
        return self._index.keys()

    def pop(self, *index: Union[int, Ref]) -&gt; Optional[Entity]:
        &#34;&#34;&#34;Delete the row at index or with specified Ref id. If multiple
        index/key was specified, all row was removed. Return the old value of
        the first deleted item.

        Args:
            *index: A list of index (position or reference)
        &#34;&#34;&#34;
        ret_value = None
        for key in sorted(index, reverse=True):  # Remove index at the end
            if isinstance(key, int):
                if not 0 &lt;= key &lt; len(self._row):
                    ret_value = None
                else:
                    if &#34;id&#34; in self._row[key] and self._index:
                        del self._index[self._row[key][&#39;id&#39;]]
                    ret_value = self._row[key]
                    del self._row[key]
            else:
                if not self._index:
                    self.reindex()
                if key not in self._index:
                    ret_value = None
                else:
                    self._row.remove(self._index[key])
                    ret_value = self._index.pop(key)
        return cast(Optional[Entity], ret_value)

    def insert(self, index: int, value: Entity) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;Insert a new entity before the index position.

        Args:
            index: The position where to insert
            value: The new entity to add
        Returns
            `self`
        &#34;&#34;&#34;
        if not isinstance(value, dict):
            raise TypeError(&#39;value must be a dict&#39;)
        for val in value.values():
            self._detect_or_validate(val)
        self._row.insert(index, value)
        if &#34;id&#34; in value:
            if not self._index:
                self.reindex()
            self._index[value[&#34;id&#34;]] = value
        return self

    def reindex(self) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;Reindex the grid if the user, update directly an id of a row.
        Returns
            `self`
        &#34;&#34;&#34;
        self._index = {}
        for item in self._row:
            if &#34;id&#34; in item:
                assert isinstance(item[&#34;id&#34;], Ref), &#34;The &#39;id&#39; tag must be a reference&#34;
                self._index[item[&#34;id&#34;]] = item
        return self

    def pack_columns(self) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;
        Remove unused columns.
        Returns:
            `self`
        &#34;&#34;&#34;
        using_columns = set()
        columns_keys = self.column.keys()
        for row in self._row:
            for col_name in columns_keys:
                if col_name in row:
                    using_columns.add(col_name)
                if len(using_columns) == len(columns_keys):  # All columns was found
                    return self
        self.column = {k: self.column[k] for k in using_columns}
        return self

    def extends_columns(self) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;
        Add missing columns

        Returns:
            `self`
        &#34;&#34;&#34;
        new_cols = self.column.copy()
        for row in self._row:
            for k in row.keys():
                if k not in new_cols:
                    new_cols[k] = {}
        self.column = new_cols
        return self

    def extend(self, values: Iterable[Entity]) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;
        Add a list of entities inside the grid

        Args:
            values: The list of entities to insert.
        Returns:
            `self`
        &#34;&#34;&#34;
        super().extend(values)
        for item in self._row:
            if &#34;id&#34; in item:
                self._index[item[&#34;id&#34;]] = item
        return self

    def sort(self, tag: str) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;
        Sort the entity by a specific tag
        Args:
            tag: The tag to use to sort the entity
        Returns:
            `self`
        &#34;&#34;&#34;
        self._row = sorted(self._row, key=lambda row: row[tag])
        return self

    def copy(self) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34; Create a copy of current grid.

        The corresponding entities were duplicate

        Returns:
            A copy of the current grid.
        &#34;&#34;&#34;
        a_copy = copy.deepcopy(self)
        a_copy._index = None  # Remove index pylint: disable=protected-access
        return a_copy

    def filter(self, grid_filter: str, limit: int = 0) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;Return a filter version of this grid.

        The entities were share between original grid and the result.

        Use a `grid.filter(...).deepcopy()` if you not want to share metadata, columns
        and rows

        Args:
            grid_filter: The filter expression (see specification)
            limit: The maximum number of result
        Returns:
            A new grid with only the selected entities.
        &#34;&#34;&#34;
        assert limit &gt;= 0
        from .grid_filter import filter_function  # pylint: disable: import-outside-toplevel
        if grid_filter is None or grid_filter.strip() == &#39;&#39;:
            if limit == 0:
                return self
            result = Grid(version=self.version, metadata=self.metadata, columns=self.column)
            result.extend(self.__getitem__(slice(0, limit)))
            return result

        result = Grid(version=self.version, metadata=self.metadata, columns=self.column)
        a_filter = filter_function(grid_filter)
        for row in self._row:
            if a_filter(self, row):
                result.append(row)
            if limit and len(result) == limit:
                break
        return result

    def select(self, select: Optional[str]) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;
        Select only some tags in the grid.
        Args:
            select: A list a tags (accept operator ! to exclude some columns)
        Returns:
             A new grid with only selected columns. Use grid.purge_grid() to update the entities.
        &#34;&#34;&#34;
        if select:
            select = select.strip()
            if select not in [&#34;*&#34;, &#39;&#39;]:
                if &#39;!&#39; in select:
                    new_cols = copy.deepcopy(self.column)
                    new_grid = Grid(version=self.version, metadata=self.metadata, columns=new_cols)
                    for col in re.split(&#39;[, ]&#39;, select):
                        col = col.strip()
                        if not col.startswith(&#39;!&#39;):
                            raise ValueError(&#34;Impossible to merge positive and negative selection&#34;)
                        if col[1:] in new_cols:
                            del new_cols[col[1:]]
                    new_grid.column = new_cols
                    return new_grid
                new_cols = SortableDict()
                new_grid = cast(Grid, self[:])
                for col in re.split(&#39;[, ]&#39;, select):
                    col = col.strip()
                    if col.startswith(&#39;!&#39;):
                        raise ValueError(&#34;Impossible to merge positive and negative selection&#34;)
                    if col in self.column:
                        new_cols[col] = self.column[col]
                    else:
                        new_cols[col] = {}

                new_grid.column = new_cols
                return cast(Grid, new_grid)
        return self.copy()

    def purge(self) -&gt; &#39;Grid&#39;:
        &#34;&#34;&#34;
        Remove all tags in all entities, not in columns
        Returns:
             A new grid with entities compatible with the columns
        &#34;&#34;&#34;
        cols = self.column
        new_grid = Grid(version=self.version, metadata=self.metadata, columns=cols)
        for row in self:
            new_grid.append({key: val for key, val in row.items() if key in cols})
        return new_grid

    def _detect_or_validate(self, val: Any) -&gt; bool:
        &#34;&#34;&#34;Detect the version used from the row content, or validate against the
        version if given.
        &#34;&#34;&#34;
        if (val is NA) \
                or isinstance(val, (list, dict, SortableDict, Grid)):
            # Project Haystack 3.0 type.
            self._assert_version(VER_3_0)
        return True

    def _assert_version(self, version: Version) -&gt; None:
        &#34;&#34;&#34;Assert that the grid version is equal to or above the given value. If
        no version is set, set the version.
        &#34;&#34;&#34;
        if self.nearest_version &lt; version:
            if self._version_given:
                raise ValueError(
                    &#39;Data type requires version %s&#39; % version)
            self._version = version</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>shaystack.empty_grid._ImmuableGrid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="shaystack.Grid.column"><code class="name">var <span class="ident">column</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="shaystack.Grid.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="shaystack.Grid.nearest_version"><code class="name">var <span class="ident">nearest_version</span> :Â shaystack.version.Version</code></dt>
<dd>
<div class="desc"><p>The nearest haystack version of grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nearest_version(self) -&gt; Version:  # pragma: no cover
    &#34;&#34;&#34; The nearest haystack version of grid &#34;&#34;&#34;
    return Version.nearest(self._version)</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.version"><code class="name">var <span class="ident">version</span> :Â shaystack.version.Version</code></dt>
<dd>
<div class="desc"><p>The haystack version of grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; Version:  # pragma: no cover
    &#34;&#34;&#34; The haystack version of grid &#34;&#34;&#34;
    return self._version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="shaystack.Grid.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>S.clear() -&gt; None &ndash; remove all items from S</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self._row = []
    self._index = None</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of current grid.</p>
<p>The corresponding entities were duplicate</p>
<h2 id="returns">Returns</h2>
<p>A copy of the current grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34; Create a copy of current grid.

    The corresponding entities were duplicate

    Returns:
        A copy of the current grid.
    &#34;&#34;&#34;
    a_copy = copy.deepcopy(self)
    a_copy._index = None  # Remove index pylint: disable=protected-access
    return a_copy</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, values:Â Iterable[Dict[str,Â Union[str,Â int,Â float,Â bool,Â datetime.date,Â datetime.time,Â datetime.datetime,Â shaystack.datatypes.Ref,Â shaystack.datatypes.Quantity,Â shaystack.datatypes.Coordinate,Â shaystack.datatypes.Uri,Â shaystack.datatypes.Bin,Â shaystack.datatypes.XStr,Â shaystack.datatypes._MarkerType,Â shaystack.datatypes._NAType,Â shaystack.datatypes._RemoveType,Â List[Any],Â Dict[str,Â Any],Â NoneType]]]) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Add a list of entities inside the grid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>The list of entities to insert.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, values: Iterable[Entity]) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;
    Add a list of entities inside the grid

    Args:
        values: The list of entities to insert.
    Returns:
        `self`
    &#34;&#34;&#34;
    super().extend(values)
    for item in self._row:
        if &#34;id&#34; in item:
            self._index[item[&#34;id&#34;]] = item
    return self</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.extends_columns"><code class="name flex">
<span>def <span class="ident">extends_columns</span></span>(<span>self) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Add missing columns</p>
<h2 id="returns">Returns</h2>
<p><code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extends_columns(self) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;
    Add missing columns

    Returns:
        `self`
    &#34;&#34;&#34;
    new_cols = self.column.copy()
    for row in self._row:
        for k in row.keys():
            if k not in new_cols:
                new_cols[k] = {}
    self.column = new_cols
    return self</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, grid_filter:Â str, limit:Â intÂ =Â 0) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Return a filter version of this grid.</p>
<p>The entities were share between original grid and the result.</p>
<p>Use a <code>grid.filter(&hellip;).deepcopy()</code> if you not want to share metadata, columns
and rows</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid_filter</code></strong></dt>
<dd>The filter expression (see specification)</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>The maximum number of result</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new grid with only the selected entities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, grid_filter: str, limit: int = 0) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;Return a filter version of this grid.

    The entities were share between original grid and the result.

    Use a `grid.filter(...).deepcopy()` if you not want to share metadata, columns
    and rows

    Args:
        grid_filter: The filter expression (see specification)
        limit: The maximum number of result
    Returns:
        A new grid with only the selected entities.
    &#34;&#34;&#34;
    assert limit &gt;= 0
    from .grid_filter import filter_function  # pylint: disable: import-outside-toplevel
    if grid_filter is None or grid_filter.strip() == &#39;&#39;:
        if limit == 0:
            return self
        result = Grid(version=self.version, metadata=self.metadata, columns=self.column)
        result.extend(self.__getitem__(slice(0, limit)))
        return result

    result = Grid(version=self.version, metadata=self.metadata, columns=self.column)
    a_filter = filter_function(grid_filter)
    for row in self._row:
        if a_filter(self, row):
            result.append(row)
        if limit and len(result) == limit:
            break
    return result</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, index:Â shaystack.datatypes.Ref, default:Â Union[Dict[str,Â Union[str,Â int,Â float,Â bool,Â datetime.date,Â datetime.time,Â datetime.datetime,Â shaystack.datatypes.Ref,Â shaystack.datatypes.Quantity,Â shaystack.datatypes.Coordinate,Â shaystack.datatypes.Uri,Â shaystack.datatypes.Bin,Â shaystack.datatypes.XStr,Â shaystack.datatypes._MarkerType,Â shaystack.datatypes._NAType,Â shaystack.datatypes._RemoveType,Â List[Any],Â Dict[str,Â Any],Â NoneType]],Â NoneType]Â =Â None) â€‘>Â Dict[str,Â Union[str,Â int,Â float,Â bool,Â datetime.date,Â datetime.time,Â datetime.datetime,Â shaystack.datatypes.Ref,Â shaystack.datatypes.Quantity,Â shaystack.datatypes.Coordinate,Â shaystack.datatypes.Uri,Â shaystack.datatypes.Bin,Â shaystack.datatypes.XStr,Â shaystack.datatypes._MarkerType,Â shaystack.datatypes._NAType,Â shaystack.datatypes._RemoveType,Â List[Any],Â Dict[str,Â Any],Â NoneType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return an entity with the corresponding id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>The id of entity</dd>
<dt><strong><code>default</code></strong></dt>
<dd>The default value if the entity is not found</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The entity with the id == index or the default value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, index: Ref, default: Optional[Entity] = None) -&gt; Entity:
    &#34;&#34;&#34;Return an entity with the corresponding id.

    Args:
        index: The id of entity
        default: The default value if the entity is not found

    Returns:
        The entity with the id == index or the default value
    &#34;&#34;&#34;
    if not self._index:
        self.reindex()
    return cast(Entity, self._index.get(index, default))</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, index:Â int, value:Â Dict[str,Â Union[str,Â int,Â float,Â bool,Â datetime.date,Â datetime.time,Â datetime.datetime,Â shaystack.datatypes.Ref,Â shaystack.datatypes.Quantity,Â shaystack.datatypes.Coordinate,Â shaystack.datatypes.Uri,Â shaystack.datatypes.Bin,Â shaystack.datatypes.XStr,Â shaystack.datatypes._MarkerType,Â shaystack.datatypes._NAType,Â shaystack.datatypes._RemoveType,Â List[Any],Â Dict[str,Â Any],Â NoneType]]) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Insert a new entity before the index position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>The position where to insert</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The new entity to add</dd>
</dl>
<p>Returns
<code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, index: int, value: Entity) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;Insert a new entity before the index position.

    Args:
        index: The position where to insert
        value: The new entity to add
    Returns
        `self`
    &#34;&#34;&#34;
    if not isinstance(value, dict):
        raise TypeError(&#39;value must be a dict&#39;)
    for val in value.values():
        self._detect_or_validate(val)
    self._row.insert(index, value)
    if &#34;id&#34; in value:
        if not self._index:
            self.reindex()
        self._index[value[&#34;id&#34;]] = value
    return self</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self) â€‘>Â KeysView[shaystack.datatypes.Ref]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of ids of entities with <code>id</code></p>
<h2 id="returns">Returns</h2>
<p>The list of ids of entities with <code>id</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self) -&gt; KeysView[Ref]:
    &#34;&#34;&#34; Return the list of ids of entities with `id`

    Returns:
         The list of ids of entities with `id`
    &#34;&#34;&#34;
    if not self._index:
        self.reindex()
    return self._index.keys()</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.pack_columns"><code class="name flex">
<span>def <span class="ident">pack_columns</span></span>(<span>self) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Remove unused columns.</p>
<h2 id="returns">Returns</h2>
<p><code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack_columns(self) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;
    Remove unused columns.
    Returns:
        `self`
    &#34;&#34;&#34;
    using_columns = set()
    columns_keys = self.column.keys()
    for row in self._row:
        for col_name in columns_keys:
            if col_name in row:
                using_columns.add(col_name)
            if len(using_columns) == len(columns_keys):  # All columns was found
                return self
    self.column = {k: self.column[k] for k in using_columns}
    return self</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, *index:Â Union[int,Â shaystack.datatypes.Ref]) â€‘>Â Union[Dict[str,Â Union[str,Â int,Â float,Â bool,Â datetime.date,Â datetime.time,Â datetime.datetime,Â shaystack.datatypes.Ref,Â shaystack.datatypes.Quantity,Â shaystack.datatypes.Coordinate,Â shaystack.datatypes.Uri,Â shaystack.datatypes.Bin,Â shaystack.datatypes.XStr,Â shaystack.datatypes._MarkerType,Â shaystack.datatypes._NAType,Â shaystack.datatypes._RemoveType,Â List[Any],Â Dict[str,Â Any],Â NoneType]],Â NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the row at index or with specified Ref id. If multiple
index/key was specified, all row was removed. Return the old value of
the first deleted item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*index</code></strong></dt>
<dd>A list of index (position or reference)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, *index: Union[int, Ref]) -&gt; Optional[Entity]:
    &#34;&#34;&#34;Delete the row at index or with specified Ref id. If multiple
    index/key was specified, all row was removed. Return the old value of
    the first deleted item.

    Args:
        *index: A list of index (position or reference)
    &#34;&#34;&#34;
    ret_value = None
    for key in sorted(index, reverse=True):  # Remove index at the end
        if isinstance(key, int):
            if not 0 &lt;= key &lt; len(self._row):
                ret_value = None
            else:
                if &#34;id&#34; in self._row[key] and self._index:
                    del self._index[self._row[key][&#39;id&#39;]]
                ret_value = self._row[key]
                del self._row[key]
        else:
            if not self._index:
                self.reindex()
            if key not in self._index:
                ret_value = None
            else:
                self._row.remove(self._index[key])
                ret_value = self._index.pop(key)
    return cast(Optional[Entity], ret_value)</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.purge"><code class="name flex">
<span>def <span class="ident">purge</span></span>(<span>self) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all tags in all entities, not in columns</p>
<h2 id="returns">Returns</h2>
<p>A new grid with entities compatible with the columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge(self) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;
    Remove all tags in all entities, not in columns
    Returns:
         A new grid with entities compatible with the columns
    &#34;&#34;&#34;
    cols = self.column
    new_grid = Grid(version=self.version, metadata=self.metadata, columns=cols)
    for row in self:
        new_grid.append({key: val for key, val in row.items() if key in cols})
    return new_grid</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.reindex"><code class="name flex">
<span>def <span class="ident">reindex</span></span>(<span>self) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Reindex the grid if the user, update directly an id of a row.
Returns
<code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reindex(self) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;Reindex the grid if the user, update directly an id of a row.
    Returns
        `self`
    &#34;&#34;&#34;
    self._index = {}
    for item in self._row:
        if &#34;id&#34; in item:
            assert isinstance(item[&#34;id&#34;], Ref), &#34;The &#39;id&#39; tag must be a reference&#34;
            self._index[item[&#34;id&#34;]] = item
    return self</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, select:Â Union[str,Â NoneType]) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Select only some tags in the grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>select</code></strong></dt>
<dd>A list a tags (accept operator ! to exclude some columns)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new grid with only selected columns. Use grid.purge_grid() to update the entities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, select: Optional[str]) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;
    Select only some tags in the grid.
    Args:
        select: A list a tags (accept operator ! to exclude some columns)
    Returns:
         A new grid with only selected columns. Use grid.purge_grid() to update the entities.
    &#34;&#34;&#34;
    if select:
        select = select.strip()
        if select not in [&#34;*&#34;, &#39;&#39;]:
            if &#39;!&#39; in select:
                new_cols = copy.deepcopy(self.column)
                new_grid = Grid(version=self.version, metadata=self.metadata, columns=new_cols)
                for col in re.split(&#39;[, ]&#39;, select):
                    col = col.strip()
                    if not col.startswith(&#39;!&#39;):
                        raise ValueError(&#34;Impossible to merge positive and negative selection&#34;)
                    if col[1:] in new_cols:
                        del new_cols[col[1:]]
                new_grid.column = new_cols
                return new_grid
            new_cols = SortableDict()
            new_grid = cast(Grid, self[:])
            for col in re.split(&#39;[, ]&#39;, select):
                col = col.strip()
                if col.startswith(&#39;!&#39;):
                    raise ValueError(&#34;Impossible to merge positive and negative selection&#34;)
                if col in self.column:
                    new_cols[col] = self.column[col]
                else:
                    new_cols[col] = {}

            new_grid.column = new_cols
            return cast(Grid, new_grid)
    return self.copy()</code></pre>
</details>
</dd>
<dt id="shaystack.Grid.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, tag:Â str) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Sort the entity by a specific tag</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong></dt>
<dd>The tag to use to sort the entity</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, tag: str) -&gt; &#39;Grid&#39;:
    &#34;&#34;&#34;
    Sort the entity by a specific tag
    Args:
        tag: The tag to use to sort the entity
    Returns:
        `self`
    &#34;&#34;&#34;
    self._row = sorted(self._row, key=lambda row: row[tag])
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="shaystack.HaystackInterface"><code class="flex name class">
<span>class <span class="ident">HaystackInterface</span></span>
<span>(</span><span>envs:Â Dict[str,Â str])</span>
</code></dt>
<dd>
<div class="desc"><p>Interface to implement to be compatible with Haystack REST protocol.
The subclasses may be abstract (implemented only a part of methods),
the 'ops' code detect that, and can calculate the set of implemented operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HaystackInterface(ABC):
    &#34;&#34;&#34;
    Interface to implement to be compatible with Haystack REST protocol.
    The subclasses may be abstract (implemented only a part of methods),
    the &#39;ops&#39; code detect that, and can calculate the set of implemented operations.
    &#34;&#34;&#34;
    __slots__ = [&#39;_envs&#39;]

    def __init__(self, envs: Dict[str, str]):
        assert envs is not None
        self._envs = envs

    @property
    @abstractmethod
    def name(self) -&gt; str:
        &#34;&#34;&#34; The name of the provider. &#34;&#34;&#34;
        raise NotImplementedError()

    def __repr__(self) -&gt; str:
        return self.name

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        pass

    # noinspection PyMethodMayBeStatic
    def get_tz(self) -&gt; BaseTzInfo:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Return server time zone. &#34;&#34;&#34;
        return get_localzone()

    def get_customer_id(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Override this for multi-tenant.
        May be, extract the customer id from the current `Principal`.
        &#34;&#34;&#34;
        return &#39;&#39;

    def values_for_tag(self, tag: str,
                       date_version: Optional[datetime] = None) -&gt; List[Any]:
        &#34;&#34;&#34;Get all values for a given tag.

        Args:
            tag: The tag to analyse.
            date_version: version date of the ontology.

        Returns:
            All unique values for a specific tag
        &#34;&#34;&#34;
        raise NotImplementedError()

    def versions(self) -&gt; List[datetime]:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Return a list of versions fot the current ontology.
        Returns:
            datetime for each version or empty array if unknown
        &#34;&#34;&#34;
        return []

    @abstractmethod
    def about(self, home: str) -&gt; Grid:
        &#34;&#34;&#34;Implement the Haystack &#39;about&#39; ops.

        The subclasse must complet the result with &#34;productUri&#34;, &#34;productVersion&#34;, &#34;moduleName&#34;
        and &#34;moduleVersion&#34;

        Args:
            home: Home url of the API

        Returns:
            The default &#39;about&#39; grid.
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns=[
                &#34;haystackVersion&#34;,  # Str version of REST implementation
                &#34;tz&#34;,  # Str of server&#39;s default timezone
                &#34;serverName&#34;,  # Str name of the server or project database
                &#34;serverTime&#34;,
                &#34;serverBootTime&#34;,
                &#34;productName&#34;,  # Str name of the server software product
                &#34;productUri&#34;,
                &#34;productVersion&#34;,
                # module which implements Haystack server protocol
                &#34;moduleName&#34;,
                # if its a plug-in to the product
                &#34;moduleVersion&#34;  # Str version of moduleName
            ],
        )
        grid.append(
            {
                &#34;haystackVersion&#34;: str(VER_3_0),
                &#34;tz&#34;: str(self.get_tz()),
                &#34;serverName&#34;: &#34;haystack_&#34; + self._envs.get(&#34;AWS_REGION&#34;, &#34;local&#34;),
                &#34;serverTime&#34;: datetime.now(tz=self.get_tz()).replace(microsecond=0),
                &#34;serverBootTime&#34;: datetime.now(tz=self.get_tz()).replace(
                    microsecond=0
                ),
                &#34;productName&#34;: &#34;Haystack Provider&#34;,
                &#34;productUri&#34;: Uri(home),
                &#34;productVersion&#34;: &#34;0.1&#34;,
                &#34;moduleName&#34;: &#34;AbstractProvider&#34;,
                &#34;moduleVersion&#34;: &#34;0.1&#34;,
            }
        )
        return grid

    # noinspection PyUnresolvedReferences
    def ops(self) -&gt; Grid:
        &#34;&#34;&#34; Implement the Haystack &#39;ops&#39; ops.

        Notes:
            Automatically calculate the implemented version.

        Returns:
            A Grid containing &#39;ops&#39; name operations and its related description
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns={
                &#34;name&#34;: {},
                &#34;summary&#34;: {},
            },
        )
        all_haystack_ops = {
            &#34;about&#34;: &#34;Summary information for server&#34;,
            &#34;ops&#34;: &#34;Operations supported by this server&#34;,
            &#34;formats&#34;: &#34;Grid data formats supported by this server&#34;,
            &#34;read&#34;: &#34;The read op is used to read a set of entity records either by their unique &#34;
                    &#34;identifier or using a filter.&#34;,
            &#34;nav&#34;: &#34;The nav op is used navigate a project for learning and discovery&#34;,
            &#34;watch_sub&#34;: &#34;The watch_sub operation is used to create new watches &#34;
                         &#34;or add entities to an existing watch.&#34;,
            &#34;watch_unsub&#34;: &#34;The watch_unsub operation is used to close a watch entirely &#34;
                           &#34;or remove entities from a watch.&#34;,
            &#34;watch_poll&#34;: &#34;The watch_poll operation is used to poll a watch for &#34;
                          &#34;changes to the subscribed entity records.&#34;,
            &#34;point_write&#34;: &#34;The point_write_read op is used to: read the current status of a &#34;
                           &#34;writable point&#39;s priority array &#34;
                           &#34;or write to a given level&#34;,
            &#34;his_read&#34;: &#34;The his_read op is used to read a time-series data &#34;
                        &#34;from historized point.&#34;,
            &#34;his_write&#34;: &#34;The his_write op is used to post new time-series &#34;
                         &#34;data to a historized point.&#34;,
            &#34;invoke_action&#34;: &#34;The invoke_action op is used to invoke a &#34;
                             &#34;user action on a target record.&#34;,
        }
        # Remove abstract method
        # noinspection PyUnresolvedReferences
        for abstract_method in self.__class__.__base__.__abstractmethods__:
            all_haystack_ops.pop(abstract_method, None)
        if (
                &#34;point_write_read&#34; in self.__class__.__base__.__abstractmethods__
                or &#34;point_write_write&#34; in self.__class__.__base__.__abstractmethods__
        ):
            all_haystack_ops.pop(&#34;point_write&#34;, None)
        all_haystack_ops = {_to_camel(k): v for k, v in all_haystack_ops.items()}

        grid.extend(
            [
                {&#34;name&#34;: name, &#34;summary&#34;: summary}
                for name, summary in all_haystack_ops.items()
            ]
        )
        return grid

    def formats(self) -&gt; Optional[Grid]:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;formats&#39; ops.

        Notes:
            Implement this method, only if you want to limit the format negotiation
        Returns:
            The grid format or None. If None, the API accept all formats ZINC, TRIO, JSON and CSV.
        &#34;&#34;&#34;
        return None  # type: ignore

    @abstractmethod
    def read(
            self,
            limit: int,
            select: Optional[str],
            entity_ids: Optional[List[Ref]],
            grid_filter: Optional[str],
            date_version: Optional[datetime],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;read&#39; ops.

        Args:
            limit: The number of record to return or zero
            select: The selected tag separated with comma, else &#39;&#39; or &#39;*&#39;
            entity_ids: A list en ids. If set, grid_filter and limit are ignored.
            grid_filter: A filter to apply. Ignored if entity_ids is set.
            date_version: The date of the ontology version.

        Returns:
            The requested Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def nav(self, nav_id: str) -&gt; Any:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;nav&#39; ops.
        This operation allows servers to expose the database in a human-friendly tree (or graph)
        that can be explored

        Args:
             nav_id: The string for nav id column
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_sub(
            self,
            watch_dis: str,
            watch_id: Optional[str],
            ids: List[Ref],
            lease: Optional[int],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchSub&#39; ops.

        Args:
            watch_dis: Watch description
            watch_id: The user watch_id to update or None.
            ids: The list of ids to watch.
            lease: Lease to apply.

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_unsub(
            self, watch_id: str, ids: List[Ref], close: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchUnsub&#39; ops.

        Args:
            watch_id: The user watch_id to update or None
            ids: The list of ids to watch
            close: Set to True to close

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_poll(
            self, watch_id: str, refresh: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;watchPoll&#39; ops.

        Args:
            watch_id: The user watch_id to update or None
            refresh: Set to True for refreshing the data

        Returns:
            A Grid where each row corresponds to a watched entity.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_read(
            self, entity_id: Ref, date_version: Optional[datetime]
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

        Args:
            entity_id: The entity to update
            date_version: The optional date version to update

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_write(
            self,
            entity_id: Ref,
            level: int,
            val: Optional[Any],
            duration: Quantity,
            who: Optional[str],
            date_version: Optional[datetime] = None,
    ) -&gt; None:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

        Args:
            entity_id: The entity to update
            level: Number from 1-17 for level to write
            val: Value to write or null to auto the level
            duration: Number with duration unit if setting level 8
            who: Optional username performing the write, otherwise user dis is used
            date_version: The optional date version to update

        Returns:
            None
        &#34;&#34;&#34;
        raise NotImplementedError()

    # Date dates_range must be:
    # &#34;today&#34;
    # &#34;yesterday&#34;
    # &#34;{date}&#34;
    # &#34;{date},{date}&#34;
    # &#34;{dateTime},{dateTime}&#34;
    # &#34;{dateTime}&#34;
    @abstractmethod
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Tuple[datetime, datetime],
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisRead&#39; ops.

        Args:
            entity_id: The entity to read
            dates_range: May be &#34;today&#34;, &#34;yesterday&#34;, {date}, ({date},{date}), ({datetime},{datetime}),
            {dateTime}
            date_version: The optional date version to read

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def his_write(
            self,
            entity_id: Ref,
            time_series: Grid,
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisWrite&#39; ops.

        Args:
            entity_id: The entity to read
            time_series: A grid with a time series
            date_version: The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def invoke_action(
            self,
            entity_id: Ref,
            action: str,
            params: Dict[str, Any],
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;invokeAction&#39; ops.

        Args:
            entity_id: The entity to read
            action: The action string
            params: A dictionary with parameters
            date_version: The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface" href="providers/db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface">DBHaystackInterface</a></li>
<li><a title="shaystack.providers.ping.Provider" href="providers/ping.html#shaystack.providers.ping.Provider">Provider</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="shaystack.HaystackInterface.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The name of the provider.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def name(self) -&gt; str:
    &#34;&#34;&#34; The name of the provider. &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="shaystack.HaystackInterface.about"><code class="name flex">
<span>def <span class="ident">about</span></span>(<span>self, home:Â str) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'about' ops.</p>
<p>The subclasse must complet the result with "productUri", "productVersion", "moduleName"
and "moduleVersion"</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>home</code></strong></dt>
<dd>Home url of the API</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The default 'about' grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def about(self, home: str) -&gt; Grid:
    &#34;&#34;&#34;Implement the Haystack &#39;about&#39; ops.

    The subclasse must complet the result with &#34;productUri&#34;, &#34;productVersion&#34;, &#34;moduleName&#34;
    and &#34;moduleVersion&#34;

    Args:
        home: Home url of the API

    Returns:
        The default &#39;about&#39; grid.
    &#34;&#34;&#34;
    grid = Grid(
        version=VER_3_0,
        columns=[
            &#34;haystackVersion&#34;,  # Str version of REST implementation
            &#34;tz&#34;,  # Str of server&#39;s default timezone
            &#34;serverName&#34;,  # Str name of the server or project database
            &#34;serverTime&#34;,
            &#34;serverBootTime&#34;,
            &#34;productName&#34;,  # Str name of the server software product
            &#34;productUri&#34;,
            &#34;productVersion&#34;,
            # module which implements Haystack server protocol
            &#34;moduleName&#34;,
            # if its a plug-in to the product
            &#34;moduleVersion&#34;  # Str version of moduleName
        ],
    )
    grid.append(
        {
            &#34;haystackVersion&#34;: str(VER_3_0),
            &#34;tz&#34;: str(self.get_tz()),
            &#34;serverName&#34;: &#34;haystack_&#34; + self._envs.get(&#34;AWS_REGION&#34;, &#34;local&#34;),
            &#34;serverTime&#34;: datetime.now(tz=self.get_tz()).replace(microsecond=0),
            &#34;serverBootTime&#34;: datetime.now(tz=self.get_tz()).replace(
                microsecond=0
            ),
            &#34;productName&#34;: &#34;Haystack Provider&#34;,
            &#34;productUri&#34;: Uri(home),
            &#34;productVersion&#34;: &#34;0.1&#34;,
            &#34;moduleName&#34;: &#34;AbstractProvider&#34;,
            &#34;moduleVersion&#34;: &#34;0.1&#34;,
        }
    )
    return grid</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.formats"><code class="name flex">
<span>def <span class="ident">formats</span></span>(<span>self) â€‘>Â Union[shaystack.grid.Grid,Â NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'formats' ops.</p>
<h2 id="notes">Notes</h2>
<p>Implement this method, only if you want to limit the format negotiation</p>
<h2 id="returns">Returns</h2>
<p>The grid format or None. If None, the API accept all formats ZINC, TRIO, JSON and CSV.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats(self) -&gt; Optional[Grid]:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;formats&#39; ops.

    Notes:
        Implement this method, only if you want to limit the format negotiation
    Returns:
        The grid format or None. If None, the API accept all formats ZINC, TRIO, JSON and CSV.
    &#34;&#34;&#34;
    return None  # type: ignore</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.get_customer_id"><code class="name flex">
<span>def <span class="ident">get_customer_id</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Override this for multi-tenant.
May be, extract the customer id from the current <code>Principal</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_customer_id(self) -&gt; str:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Override this for multi-tenant.
    May be, extract the customer id from the current `Principal`.
    &#34;&#34;&#34;
    return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.get_tz"><code class="name flex">
<span>def <span class="ident">get_tz</span></span>(<span>self) â€‘>Â pytz.tzinfo.BaseTzInfo</span>
</code></dt>
<dd>
<div class="desc"><p>Return server time zone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tz(self) -&gt; BaseTzInfo:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Return server time zone. &#34;&#34;&#34;
    return get_localzone()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.his_read"><code class="name flex">
<span>def <span class="ident">his_read</span></span>(<span>self, entity_id:Â shaystack.datatypes.Ref, dates_range:Â Tuple[datetime.datetime,Â datetime.datetime], date_version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'hisRead' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to read</dd>
<dt><strong><code>dates_range</code></strong></dt>
<dd>May be "today", "yesterday", {date}, ({date},{date}), ({datetime},{datetime}),</dd>
<dt>{dateTime}</dt>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def his_read(
        self,
        entity_id: Ref,
        dates_range: Tuple[datetime, datetime],
        date_version: Optional[datetime] = None,
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;hisRead&#39; ops.

    Args:
        entity_id: The entity to read
        dates_range: May be &#34;today&#34;, &#34;yesterday&#34;, {date}, ({date},{date}), ({datetime},{datetime}),
        {dateTime}
        date_version: The optional date version to read

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.his_write"><code class="name flex">
<span>def <span class="ident">his_write</span></span>(<span>self, entity_id:Â shaystack.datatypes.Ref, time_series:Â shaystack.grid.Grid, date_version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'hisWrite' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to read</dd>
<dt><strong><code>time_series</code></strong></dt>
<dd>A grid with a time series</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def his_write(
        self,
        entity_id: Ref,
        time_series: Grid,
        date_version: Optional[datetime] = None
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;hisWrite&#39; ops.

    Args:
        entity_id: The entity to read
        time_series: A grid with a time series
        date_version: The optional date version to update

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.invoke_action"><code class="name flex">
<span>def <span class="ident">invoke_action</span></span>(<span>self, entity_id:Â shaystack.datatypes.Ref, action:Â str, params:Â Dict[str,Â Any], date_version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'invokeAction' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to read</dd>
<dt><strong><code>action</code></strong></dt>
<dd>The action string</dd>
<dt><strong><code>params</code></strong></dt>
<dd>A dictionary with parameters</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def invoke_action(
        self,
        entity_id: Ref,
        action: str,
        params: Dict[str, Any],
        date_version: Optional[datetime] = None
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;invokeAction&#39; ops.

    Args:
        entity_id: The entity to read
        action: The action string
        params: A dictionary with parameters
        date_version: The optional date version to update

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.nav"><code class="name flex">
<span>def <span class="ident">nav</span></span>(<span>self, nav_id:Â str) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'nav' ops.
This operation allows servers to expose the database in a human-friendly tree (or graph)
that can be explored</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nav_id</code></strong></dt>
<dd>The string for nav id column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def nav(self, nav_id: str) -&gt; Any:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;nav&#39; ops.
    This operation allows servers to expose the database in a human-friendly tree (or graph)
    that can be explored

    Args:
         nav_id: The string for nav id column
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.ops"><code class="name flex">
<span>def <span class="ident">ops</span></span>(<span>self) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'ops' ops.</p>
<h2 id="notes">Notes</h2>
<p>Automatically calculate the implemented version.</p>
<h2 id="returns">Returns</h2>
<p>A Grid containing 'ops' name operations and its related description</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ops(self) -&gt; Grid:
    &#34;&#34;&#34; Implement the Haystack &#39;ops&#39; ops.

    Notes:
        Automatically calculate the implemented version.

    Returns:
        A Grid containing &#39;ops&#39; name operations and its related description
    &#34;&#34;&#34;
    grid = Grid(
        version=VER_3_0,
        columns={
            &#34;name&#34;: {},
            &#34;summary&#34;: {},
        },
    )
    all_haystack_ops = {
        &#34;about&#34;: &#34;Summary information for server&#34;,
        &#34;ops&#34;: &#34;Operations supported by this server&#34;,
        &#34;formats&#34;: &#34;Grid data formats supported by this server&#34;,
        &#34;read&#34;: &#34;The read op is used to read a set of entity records either by their unique &#34;
                &#34;identifier or using a filter.&#34;,
        &#34;nav&#34;: &#34;The nav op is used navigate a project for learning and discovery&#34;,
        &#34;watch_sub&#34;: &#34;The watch_sub operation is used to create new watches &#34;
                     &#34;or add entities to an existing watch.&#34;,
        &#34;watch_unsub&#34;: &#34;The watch_unsub operation is used to close a watch entirely &#34;
                       &#34;or remove entities from a watch.&#34;,
        &#34;watch_poll&#34;: &#34;The watch_poll operation is used to poll a watch for &#34;
                      &#34;changes to the subscribed entity records.&#34;,
        &#34;point_write&#34;: &#34;The point_write_read op is used to: read the current status of a &#34;
                       &#34;writable point&#39;s priority array &#34;
                       &#34;or write to a given level&#34;,
        &#34;his_read&#34;: &#34;The his_read op is used to read a time-series data &#34;
                    &#34;from historized point.&#34;,
        &#34;his_write&#34;: &#34;The his_write op is used to post new time-series &#34;
                     &#34;data to a historized point.&#34;,
        &#34;invoke_action&#34;: &#34;The invoke_action op is used to invoke a &#34;
                         &#34;user action on a target record.&#34;,
    }
    # Remove abstract method
    # noinspection PyUnresolvedReferences
    for abstract_method in self.__class__.__base__.__abstractmethods__:
        all_haystack_ops.pop(abstract_method, None)
    if (
            &#34;point_write_read&#34; in self.__class__.__base__.__abstractmethods__
            or &#34;point_write_write&#34; in self.__class__.__base__.__abstractmethods__
    ):
        all_haystack_ops.pop(&#34;point_write&#34;, None)
    all_haystack_ops = {_to_camel(k): v for k, v in all_haystack_ops.items()}

    grid.extend(
        [
            {&#34;name&#34;: name, &#34;summary&#34;: summary}
            for name, summary in all_haystack_ops.items()
        ]
    )
    return grid</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.point_write_read"><code class="name flex">
<span>def <span class="ident">point_write_read</span></span>(<span>self, entity_id:Â shaystack.datatypes.Ref, date_version:Â Union[datetime.datetime,Â NoneType]) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'pointWrite' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to update</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def point_write_read(
        self, entity_id: Ref, date_version: Optional[datetime]
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

    Args:
        entity_id: The entity to update
        date_version: The optional date version to update

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.point_write_write"><code class="name flex">
<span>def <span class="ident">point_write_write</span></span>(<span>self, entity_id:Â shaystack.datatypes.Ref, level:Â int, val:Â Union[Any,Â NoneType], duration:Â shaystack.datatypes.Quantity, who:Â Union[str,Â NoneType], date_version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'pointWrite' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to update</dd>
<dt><strong><code>level</code></strong></dt>
<dd>Number from 1-17 for level to write</dd>
<dt><strong><code>val</code></strong></dt>
<dd>Value to write or null to auto the level</dd>
<dt><strong><code>duration</code></strong></dt>
<dd>Number with duration unit if setting level 8</dd>
<dt><strong><code>who</code></strong></dt>
<dd>Optional username performing the write, otherwise user dis is used</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def point_write_write(
        self,
        entity_id: Ref,
        level: int,
        val: Optional[Any],
        duration: Quantity,
        who: Optional[str],
        date_version: Optional[datetime] = None,
) -&gt; None:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

    Args:
        entity_id: The entity to update
        level: Number from 1-17 for level to write
        val: Value to write or null to auto the level
        duration: Number with duration unit if setting level 8
        who: Optional username performing the write, otherwise user dis is used
        date_version: The optional date version to update

    Returns:
        None
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, limit:Â int, select:Â Union[str,Â NoneType], entity_ids:Â Union[List[shaystack.datatypes.Ref],Â NoneType], grid_filter:Â Union[str,Â NoneType], date_version:Â Union[datetime.datetime,Â NoneType]) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'read' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong></dt>
<dd>The number of record to return or zero</dd>
<dt><strong><code>select</code></strong></dt>
<dd>The selected tag separated with comma, else '' or '*'</dd>
<dt><strong><code>entity_ids</code></strong></dt>
<dd>A list en ids. If set, grid_filter and limit are ignored.</dd>
<dt><strong><code>grid_filter</code></strong></dt>
<dd>A filter to apply. Ignored if entity_ids is set.</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The date of the ontology version.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(
        self,
        limit: int,
        select: Optional[str],
        entity_ids: Optional[List[Ref]],
        grid_filter: Optional[str],
        date_version: Optional[datetime],
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;read&#39; ops.

    Args:
        limit: The number of record to return or zero
        select: The selected tag separated with comma, else &#39;&#39; or &#39;*&#39;
        entity_ids: A list en ids. If set, grid_filter and limit are ignored.
        grid_filter: A filter to apply. Ignored if entity_ids is set.
        date_version: The date of the ontology version.

    Returns:
        The requested Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.values_for_tag"><code class="name flex">
<span>def <span class="ident">values_for_tag</span></span>(<span>self, tag:Â str, date_version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â List[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all values for a given tag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong></dt>
<dd>The tag to analyse.</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>version date of the ontology.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>All unique values for a specific tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values_for_tag(self, tag: str,
                   date_version: Optional[datetime] = None) -&gt; List[Any]:
    &#34;&#34;&#34;Get all values for a given tag.

    Args:
        tag: The tag to analyse.
        date_version: version date of the ontology.

    Returns:
        All unique values for a specific tag
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.versions"><code class="name flex">
<span>def <span class="ident">versions</span></span>(<span>self) â€‘>Â List[datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of versions fot the current ontology.</p>
<h2 id="returns">Returns</h2>
<p>datetime for each version or empty array if unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def versions(self) -&gt; List[datetime]:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Return a list of versions fot the current ontology.
    Returns:
        datetime for each version or empty array if unknown
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.watch_poll"><code class="name flex">
<span>def <span class="ident">watch_poll</span></span>(<span>self, watch_id:Â str, refresh:Â bool) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchPoll' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_id</code></strong></dt>
<dd>The user watch_id to update or None</dd>
<dt><strong><code>refresh</code></strong></dt>
<dd>Set to True for refreshing the data</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid where each row corresponds to a watched entity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_poll(
        self, watch_id: str, refresh: bool
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;watchPoll&#39; ops.

    Args:
        watch_id: The user watch_id to update or None
        refresh: Set to True for refreshing the data

    Returns:
        A Grid where each row corresponds to a watched entity.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.watch_sub"><code class="name flex">
<span>def <span class="ident">watch_sub</span></span>(<span>self, watch_dis:Â str, watch_id:Â Union[str,Â NoneType], ids:Â List[shaystack.datatypes.Ref], lease:Â Union[int,Â NoneType]) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchSub' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_dis</code></strong></dt>
<dd>Watch description</dd>
<dt><strong><code>watch_id</code></strong></dt>
<dd>The user watch_id to update or None.</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>The list of ids to watch.</dd>
<dt><strong><code>lease</code></strong></dt>
<dd>Lease to apply.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_sub(
        self,
        watch_dis: str,
        watch_id: Optional[str],
        ids: List[Ref],
        lease: Optional[int],
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;watchSub&#39; ops.

    Args:
        watch_dis: Watch description
        watch_id: The user watch_id to update or None.
        ids: The list of ids to watch.
        lease: Lease to apply.

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.HaystackInterface.watch_unsub"><code class="name flex">
<span>def <span class="ident">watch_unsub</span></span>(<span>self, watch_id:Â str, ids:Â List[shaystack.datatypes.Ref], close:Â bool) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchUnsub' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_id</code></strong></dt>
<dd>The user watch_id to update or None</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>The list of ids to watch</dd>
<dt><strong><code>close</code></strong></dt>
<dd>Set to True to close</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_unsub(
        self, watch_id: str, ids: List[Ref], close: bool
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;watchUnsub&#39; ops.

    Args:
        watch_id: The user watch_id to update or None
        ids: The list of ids to watch
        close: Set to True to close

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="shaystack.MetadataObject"><code class="flex name class">
<span>class <span class="ident">MetadataObject</span></span>
<span>(</span><span>initial:Â Union[NoneType,Â List[Tuple[str,Â Any]],Â Dict[str,Â Any]]Â =Â None, validate_fn:Â Union[Callable[[Any],Â bool],Â NoneType]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>An object that contains some metadata fields.</p>
<p>Used as a convenience base-class for grids and columns, both of which have metadata.</p>
<p>A dict-like object that permits value ordering/re-ordering.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial</code></strong></dt>
<dd>Initial values</dd>
<dt><strong><code>validate_fn</code></strong></dt>
<dd>A validated function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetadataObject(SortableDict):  # pylint: disable=too-many-ancestors
    &#34;&#34;&#34;An object that contains some metadata fields.

    Used as a convenience base-class for grids and columns, both of which have metadata.
    &#34;&#34;&#34;

    def append(self, key: str, value: Any = MARKER, replace: bool = True) -&gt; &#39;MetadataObject&#39;:
        &#34;&#34;&#34;Append the item to the metadata.

        Args:
            key: The tag name
            value: The value
            replace: Flag to replace or not the value
        Returns
            `self`
        &#34;&#34;&#34;
        self.add_item(key, value, replace=replace)
        return self

    def extend(self, items: Iterable[Any], replace: bool = True) -&gt; &#39;MetadataObject&#39;:
        &#34;&#34;&#34;Append the items to the metadata.

        Args:
            items: A list of items
            replace: Flag to replace or not the value
        Returns
            `self`
        &#34;&#34;&#34;
        if isinstance(items, (dict, SortableDict)):
            items = list(items.items())

        for (key, value) in items:
            self.append(key, value, replace=replace)
        return self

    def copy(self) -&gt; &#39;MetadataObject&#39;:
        &#34;&#34;&#34;
        Deep copy of metadata
        Returns:
            A new metadata object
        &#34;&#34;&#34;
        return copy.deepcopy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>shaystack.sortabledict.SortableDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="shaystack.MetadataObject.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, key:Â str, value:Â AnyÂ =Â MARKER, replace:Â boolÂ =Â True) â€‘>Â shaystack.metadata.MetadataObject</span>
</code></dt>
<dd>
<div class="desc"><p>Append the item to the metadata.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The tag name</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The value</dd>
<dt><strong><code>replace</code></strong></dt>
<dd>Flag to replace or not the value</dd>
</dl>
<p>Returns
<code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, key: str, value: Any = MARKER, replace: bool = True) -&gt; &#39;MetadataObject&#39;:
    &#34;&#34;&#34;Append the item to the metadata.

    Args:
        key: The tag name
        value: The value
        replace: Flag to replace or not the value
    Returns
        `self`
    &#34;&#34;&#34;
    self.add_item(key, value, replace=replace)
    return self</code></pre>
</details>
</dd>
<dt id="shaystack.MetadataObject.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â shaystack.metadata.MetadataObject</span>
</code></dt>
<dd>
<div class="desc"><p>Deep copy of metadata</p>
<h2 id="returns">Returns</h2>
<p>A new metadata object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#39;MetadataObject&#39;:
    &#34;&#34;&#34;
    Deep copy of metadata
    Returns:
        A new metadata object
    &#34;&#34;&#34;
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="shaystack.MetadataObject.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, items:Â Iterable[Any], replace:Â boolÂ =Â True) â€‘>Â shaystack.metadata.MetadataObject</span>
</code></dt>
<dd>
<div class="desc"><p>Append the items to the metadata.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>items</code></strong></dt>
<dd>A list of items</dd>
<dt><strong><code>replace</code></strong></dt>
<dd>Flag to replace or not the value</dd>
</dl>
<p>Returns
<code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, items: Iterable[Any], replace: bool = True) -&gt; &#39;MetadataObject&#39;:
    &#34;&#34;&#34;Append the items to the metadata.

    Args:
        items: A list of items
        replace: Flag to replace or not the value
    Returns
        `self`
    &#34;&#34;&#34;
    if isinstance(items, (dict, SortableDict)):
        items = list(items.items())

    for (key, value) in items:
        self.append(key, value, replace=replace)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="shaystack.Quantity"><code class="flex name class">
<span>class <span class="ident">Quantity</span></span>
<span>(</span><span>value, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A quantity with unit.
The quantity use the pint framework and can be converted.
See <a href="https://pint.readthedocs.io/en/stable/tutorial.html#defining-a-quantity">here</a></p>
<h2 id="properties">Properties</h2>
<p>value: The magnitude
units: Pint unit
symbol: The original symbol</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Quantity(unit_reg.Quantity):
    &#34;&#34;&#34;
    A quantity with unit.
    The quantity use the pint framework and can be converted.
    See [here](https://pint.readthedocs.io/en/stable/tutorial.html#defining-a-quantity)

    Properties:
        value: The magnitude
        units: Pint unit
        symbol: The original symbol
    &#34;&#34;&#34;

    def __new__(cls, value, units=None):
        new_quantity = unit_reg.Quantity.__new__(Quantity, value,
                                                 _to_pint_unit(units) if units else None)
        new_quantity.symbol = units
        return new_quantity</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pint.quantity.build_quantity_class.<locals>.Quantity</li>
<li>pint.quantity.Quantity</li>
<li>pint.util.PrettyIPython</li>
<li>pint.util.SharedRegistryObject</li>
</ul>
</dd>
<dt id="shaystack.Ref"><code class="flex name class">
<span>class <span class="ident">Ref</span></span>
<span>(</span><span>name:Â str, value:Â Union[str,Â NoneType]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A reference to an object in Project Haystack.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the uniq id</dd>
<dt><strong><code>value</code></strong></dt>
<dd>the comment to describe the reference</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ref:
    &#34;&#34;&#34;A reference to an object in Project Haystack.
        Args:
            name: the uniq id
            value: the comment to describe the reference
    &#34;&#34;&#34;

    __slots__ = &#34;name&#34;, &#34;value&#34;

    def __init__(self, name: str, value: Optional[str] = None):
        if name.startswith(&#34;@&#34;):
            name = name[1:]
        assert isinstance(name, str) and re.match(&#34;^[a-zA-Z0-9_:\\-.~]+$&#34;, name)
        self.name = name
        self.value = value

    @property
    def has_value(self):
        return self.value is not None

    def __repr__(self) -&gt; str:
        return &#39;%s(%r, %r)&#39; % (
            self.__class__.__name__, self.name, self.value
        )

    def __str__(self) -&gt; str:
        if self.has_value:
            return &#39;@%s %r&#39; % (
                self.name, self.value
            )
        return &#39;@%s&#39; % self.name

    def __eq__(self, other: &#39;Ref&#39;) -&gt; bool:
        if not isinstance(other, Ref):
            return False
        return self.name == other.name

    def __ne__(self, other: &#39;Ref&#39;):
        if not isinstance(other, Ref):
            return True
        return not self == other

    def __lt__(self, other: &#39;Ref&#39;) -&gt; bool:
        return self.name.__lt__(other.name)

    def __le__(self, other: &#39;Ref&#39;) -&gt; bool:
        return self.name.__le__(other.name)

    def __gt__(self, other: &#39;Ref&#39;) -&gt; bool:
        return self.name.__gt__(other.name)

    def __ge__(self, other: &#39;Ref&#39;) -&gt; bool:
        return self.name.__ge__(other.name)

    def __hash__(self) -&gt; int:
        return hash(self.name)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="shaystack.Ref.has_value"><code class="name">var <span class="ident">has_value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_value(self):
    return self.value is not None</code></pre>
</details>
</dd>
<dt id="shaystack.Ref.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="shaystack.Ref.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="shaystack.Uri"><code class="flex name class">
<span>class <span class="ident">Uri</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>A convenience class to allow identification of a URI from other string
types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Uri(str):
    &#34;&#34;&#34;A convenience class to allow identification of a URI from other string
    types.
    &#34;&#34;&#34;

    def __repr__(self) -&gt; str:
        return &#39;%s(%s)&#39; % (self.__class__.__name__,
                           super().__repr__())

    def __eq__(self, other: &#39;Uri&#39;) -&gt; bool:
        if not isinstance(other, Uri):
            return False
        return super().__eq__(other)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
</dd>
<dt id="shaystack.Version"><code class="flex name class">
<span>class <span class="ident">Version</span></span>
<span>(</span><span>ver_str:Â Union[str,Â ForwardRef('<a title="shaystack.Version" href="#shaystack.Version">Version</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>A Project Haystack version number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ver_str</code></strong></dt>
<dd>The version str</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Version:
    &#34;&#34;&#34;A Project Haystack version number.
    Args:
        ver_str: The version str
    &#34;&#34;&#34;
    __slots__ = &#34;version_nums&#34;, &#34;version_extra&#34;

    def __init__(self, ver_str: Union[str, &#39;Version&#39;]):
        if isinstance(ver_str, Version):
            # Clone constructor
            self.version_nums = ver_str.version_nums
            self.version_extra = ver_str.version_extra
        else:
            match = _VERSION_RE.match(ver_str)
            if match is None:
                raise ValueError(&#39;Not a valid version string: %r&#39; % ver_str)

            # We should have a nice friendly dotted decimal, followed
            # by anything else not recognised.  Parse out the first bit.
            (version_nums, version_extra) = match.groups()
            if not version_nums:
                raise ValueError(&#39;Not a valid version string: %r&#39; % ver_str)
            self.version_nums = tuple([int(p or 0)  # pylint: disable=consider-using-generator
                                       for p in version_nums.split(&#39;.&#39;)])
            self.version_extra = version_extra

    def __str__(self) -&gt; str:
        base = &#39;.&#39;.join([str(p) for p in self.version_nums])
        if self.version_extra:
            base += self.version_extra
        return base

    def _cmp(self, other: Union[&#39;Version&#39;, str]) -&gt; int:
        &#34;&#34;&#34;Compare two Project Haystack version strings

        Args:
            other: Other version
        Returns
             -1 if self &lt; other, 0 if self == other or 1 if self &gt; other.
        &#34;&#34;&#34;
        if isinstance(other, str):
            other = Version(other)

        num1 = self.version_nums
        num2 = other.version_nums

        # Pad both to be the same length
        ver_len = max(len(num1), len(num2))
        num1 += tuple([0 for _ in range(len(num1), ver_len)])  # pylint: disable=consider-using-generator
        num2 += tuple([0 for _ in range(len(num2), ver_len)])  # pylint: disable=consider-using-generator

        # Compare the versions
        for (pair_1, pair_2) in zip(num1, num2):
            if pair_1 &lt; pair_2:
                return -1
            if pair_1 &gt; pair_2:
                return 1

        # All the same, compare the extra strings.
        # If a version misses the extra part; we consider that as coming *before*.
        if self.version_extra is None:
            if other.version_extra is None:
                return 0
            return -1
        if other.version_extra is None:
            return 1
        if self.version_extra == other.version_extra:
            return 0
        if self.version_extra &lt; other.version_extra:
            return -1
        return 1

    def __hash__(self) -&gt; int:
        return hash(str(self))

    # Comparison operators

    def __lt__(self, other) -&gt; bool:
        return self._cmp(other) &lt; 0

    def __le__(self, other) -&gt; bool:
        return self._cmp(other) &lt; 1

    def __eq__(self, other) -&gt; bool:
        return self._cmp(other) == 0

    def __ne__(self, other) -&gt; bool:
        return self._cmp(other) != 0

    def __ge__(self, other) -&gt; bool:
        return self._cmp(other) &gt; -1

    def __gt__(self, other) -&gt; bool:
        return self._cmp(other) &gt; 0

    @classmethod
    def nearest(cls, ver: Union[str, &#39;Version&#39;]) -&gt; &#39;Version&#39;:
        &#34;&#34;&#34;Retrieve the official version nearest the one given.

        Args:
            ver: The version to analyse
        Returns:
            The version nearest the one given
        &#34;&#34;&#34;
        if isinstance(ver, str):
            ver = Version(ver)

        if ver in OFFICIAL_VERSIONS:
            return ver

        # We might not have an exact match for that.
        # See if we have one that&#39;s newer than the grid we&#39;re looking at.
        versions = list(OFFICIAL_VERSIONS)
        versions.sort(reverse=True)
        best = None
        for candidate in versions:
            # Due to ambiguities, we might have an exact match and not know it.
            # &#39;2.0&#39; will not hash to the same value as &#39;2.0.0&#39;, but both are
            # equivalent.
            if candidate == ver:
                # We can&#39;t beat this, make a note of the match for later
                return candidate

            # If we have not seen a better candidate, and this is older
            # then we may have to settle for that.
            if (best is None) and (candidate &lt; ver):
                warnings.warn(&#39;This version of shift-4-haystack does not yet &#39;
                              &#39;support version %s, please seek a newer version &#39;
                              &#39;or file a bug.  Closest (older) version supported is %s.&#39;
                              % (ver, candidate))
                return candidate

            # Probably the best so far, but see if we can go closer
            if candidate &gt; ver:
                best = candidate

        # Unhappy path, no best option?  This should not happen.
        assert best is not None
        warnings.warn(&#39;This version of shift-4-haystack does not yet &#39;
                      &#39;support version %s, please seek a newer version &#39;
                      &#39;or file a bug.  Closest (newer) version supported is %s.&#39;
                      % (ver, best))
        return best</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="shaystack.Version.nearest"><code class="name flex">
<span>def <span class="ident">nearest</span></span>(<span>ver:Â Union[str,Â ForwardRef('<a title="shaystack.Version" href="#shaystack.Version">Version</a>')]) â€‘>Â shaystack.version.Version</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the official version nearest the one given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ver</code></strong></dt>
<dd>The version to analyse</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The version nearest the one given</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def nearest(cls, ver: Union[str, &#39;Version&#39;]) -&gt; &#39;Version&#39;:
    &#34;&#34;&#34;Retrieve the official version nearest the one given.

    Args:
        ver: The version to analyse
    Returns:
        The version nearest the one given
    &#34;&#34;&#34;
    if isinstance(ver, str):
        ver = Version(ver)

    if ver in OFFICIAL_VERSIONS:
        return ver

    # We might not have an exact match for that.
    # See if we have one that&#39;s newer than the grid we&#39;re looking at.
    versions = list(OFFICIAL_VERSIONS)
    versions.sort(reverse=True)
    best = None
    for candidate in versions:
        # Due to ambiguities, we might have an exact match and not know it.
        # &#39;2.0&#39; will not hash to the same value as &#39;2.0.0&#39;, but both are
        # equivalent.
        if candidate == ver:
            # We can&#39;t beat this, make a note of the match for later
            return candidate

        # If we have not seen a better candidate, and this is older
        # then we may have to settle for that.
        if (best is None) and (candidate &lt; ver):
            warnings.warn(&#39;This version of shift-4-haystack does not yet &#39;
                          &#39;support version %s, please seek a newer version &#39;
                          &#39;or file a bug.  Closest (older) version supported is %s.&#39;
                          % (ver, candidate))
            return candidate

        # Probably the best so far, but see if we can go closer
        if candidate &gt; ver:
            best = candidate

    # Unhappy path, no best option?  This should not happen.
    assert best is not None
    warnings.warn(&#39;This version of shift-4-haystack does not yet &#39;
                  &#39;support version %s, please seek a newer version &#39;
                  &#39;or file a bug.  Closest (newer) version supported is %s.&#39;
                  % (ver, best))
    return best</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="shaystack.Version.version_extra"><code class="name">var <span class="ident">version_extra</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="shaystack.Version.version_nums"><code class="name">var <span class="ident">version_nums</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="shaystack.XStr"><code class="flex name class">
<span>class <span class="ident">XStr</span></span>
<span>(</span><span>encoding:Â str, data:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>A convenience class to allow identification of a XStr.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>encoding</code></strong></dt>
<dd>encoding format (accept <code>hex</code> and <code>b64</code>)</dd>
<dt><strong><code>data</code></strong></dt>
<dd>The data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XStr:
    &#34;&#34;&#34;A convenience class to allow identification of a XStr.

        Args:
            encoding: encoding format (accept `hex` and `b64`)
            data: The data
    &#34;&#34;&#34;
    __slots__ = &#34;encoding&#34;, &#34;data&#34;

    def __init__(self, encoding: str, data: str):
        self.encoding = encoding
        if encoding == &#34;hex&#34;:
            self.data = bytearray.fromhex(data)
        elif encoding == &#34;b64&#34;:
            self.data = base64.b64decode(data)
        else:
            self.data = data.encode(&#39;ascii&#39;)  # Not decoded

    def data_to_string(self) -&gt; str:
        &#34;&#34;&#34;
        Dump the binary data to string with the corresponding encoding.
        Returns:
            A string
        &#34;&#34;&#34;
        if self.encoding == &#34;hex&#34;:
            return binascii.b2a_hex(self.data).decode(&#34;ascii&#34;)
        if self.encoding == &#34;b64&#34;:
            return binascii.b2a_base64(self.data, newline=False).decode(&#34;ascii&#34;)
        raise ValueError(&#34;Ignore encoding&#34;)

    def __repr__(self) -&gt; str:
        return &#39;XStr(&#34;%s&#34;,&#34;%s&#34;)&#39; % (self.encoding, self.data_to_string())

    def __eq__(self, other: &#39;XStr&#39;) -&gt; bool:
        if not isinstance(other, XStr):
            return False
        return self.data == other.data  # Check only binary data

    def __ne__(self, other: &#39;XStr&#39;) -&gt; bool:
        if not isinstance(other, XStr):
            return True
        return not self.data == other.data  # Check only binary data</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="shaystack.XStr.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="shaystack.XStr.encoding"><code class="name">var <span class="ident">encoding</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="shaystack.XStr.data_to_string"><code class="name flex">
<span>def <span class="ident">data_to_string</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Dump the binary data to string with the corresponding encoding.</p>
<h2 id="returns">Returns</h2>
<p>A string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_to_string(self) -&gt; str:
    &#34;&#34;&#34;
    Dump the binary data to string with the corresponding encoding.
    Returns:
        A string
    &#34;&#34;&#34;
    if self.encoding == &#34;hex&#34;:
        return binascii.b2a_hex(self.data).decode(&#34;ascii&#34;)
    if self.encoding == &#34;b64&#34;:
        return binascii.b2a_base64(self.data, newline=False).decode(&#34;ascii&#34;)
    raise ValueError(&#34;Ignore encoding&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="shaystack.empty_grid" href="empty_grid.html">shaystack.empty_grid</a></code></li>
<li><code><a title="shaystack.exception" href="exception.html">shaystack.exception</a></code></li>
<li><code><a title="shaystack.haysondumper" href="haysondumper.html">shaystack.haysondumper</a></code></li>
<li><code><a title="shaystack.haysonparser" href="haysonparser.html">shaystack.haysonparser</a></code></li>
<li><code><a title="shaystack.period" href="period.html">shaystack.period</a></code></li>
<li><code><a title="shaystack.providers" href="providers/index.html">shaystack.providers</a></code></li>
<li><code><a title="shaystack.tools" href="tools.html">shaystack.tools</a></code></li>
<li><code><a title="shaystack.type" href="type.html">shaystack.type</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="shaystack.MODE" href="#shaystack.MODE">MODE</a></code></li>
<li><code><a title="shaystack.about" href="#shaystack.about">about</a></code></li>
<li><code><a title="shaystack.dump" href="#shaystack.dump">dump</a></code></li>
<li><code><a title="shaystack.dump_scalar" href="#shaystack.dump_scalar">dump_scalar</a></code></li>
<li><code><a title="shaystack.formats" href="#shaystack.formats">formats</a></code></li>
<li><code><a title="shaystack.his_read" href="#shaystack.his_read">his_read</a></code></li>
<li><code><a title="shaystack.his_write" href="#shaystack.his_write">his_write</a></code></li>
<li><code><a title="shaystack.invoke_action" href="#shaystack.invoke_action">invoke_action</a></code></li>
<li><code><a title="shaystack.mode_to_suffix" href="#shaystack.mode_to_suffix">mode_to_suffix</a></code></li>
<li><code><a title="shaystack.nav" href="#shaystack.nav">nav</a></code></li>
<li><code><a title="shaystack.parse" href="#shaystack.parse">parse</a></code></li>
<li><code><a title="shaystack.parse_filter" href="#shaystack.parse_filter">parse_filter</a></code></li>
<li><code><a title="shaystack.parse_hs_datetime_format" href="#shaystack.parse_hs_datetime_format">parse_hs_datetime_format</a></code></li>
<li><code><a title="shaystack.parse_scalar" href="#shaystack.parse_scalar">parse_scalar</a></code></li>
<li><code><a title="shaystack.point_write" href="#shaystack.point_write">point_write</a></code></li>
<li><code><a title="shaystack.read" href="#shaystack.read">read</a></code></li>
<li><code><a title="shaystack.suffix_to_mode" href="#shaystack.suffix_to_mode">suffix_to_mode</a></code></li>
<li><code><a title="shaystack.watch_poll" href="#shaystack.watch_poll">watch_poll</a></code></li>
<li><code><a title="shaystack.watch_sub" href="#shaystack.watch_sub">watch_sub</a></code></li>
<li><code><a title="shaystack.watch_unsub" href="#shaystack.watch_unsub">watch_unsub</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shaystack.Bin" href="#shaystack.Bin">Bin</a></code></h4>
</li>
<li>
<h4><code><a title="shaystack.Coordinate" href="#shaystack.Coordinate">Coordinate</a></code></h4>
<ul class="">
<li><code><a title="shaystack.Coordinate.latitude" href="#shaystack.Coordinate.latitude">latitude</a></code></li>
<li><code><a title="shaystack.Coordinate.longitude" href="#shaystack.Coordinate.longitude">longitude</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shaystack.Grid" href="#shaystack.Grid">Grid</a></code></h4>
<ul class="two-column">
<li><code><a title="shaystack.Grid.clear" href="#shaystack.Grid.clear">clear</a></code></li>
<li><code><a title="shaystack.Grid.column" href="#shaystack.Grid.column">column</a></code></li>
<li><code><a title="shaystack.Grid.copy" href="#shaystack.Grid.copy">copy</a></code></li>
<li><code><a title="shaystack.Grid.extend" href="#shaystack.Grid.extend">extend</a></code></li>
<li><code><a title="shaystack.Grid.extends_columns" href="#shaystack.Grid.extends_columns">extends_columns</a></code></li>
<li><code><a title="shaystack.Grid.filter" href="#shaystack.Grid.filter">filter</a></code></li>
<li><code><a title="shaystack.Grid.get" href="#shaystack.Grid.get">get</a></code></li>
<li><code><a title="shaystack.Grid.insert" href="#shaystack.Grid.insert">insert</a></code></li>
<li><code><a title="shaystack.Grid.keys" href="#shaystack.Grid.keys">keys</a></code></li>
<li><code><a title="shaystack.Grid.metadata" href="#shaystack.Grid.metadata">metadata</a></code></li>
<li><code><a title="shaystack.Grid.nearest_version" href="#shaystack.Grid.nearest_version">nearest_version</a></code></li>
<li><code><a title="shaystack.Grid.pack_columns" href="#shaystack.Grid.pack_columns">pack_columns</a></code></li>
<li><code><a title="shaystack.Grid.pop" href="#shaystack.Grid.pop">pop</a></code></li>
<li><code><a title="shaystack.Grid.purge" href="#shaystack.Grid.purge">purge</a></code></li>
<li><code><a title="shaystack.Grid.reindex" href="#shaystack.Grid.reindex">reindex</a></code></li>
<li><code><a title="shaystack.Grid.select" href="#shaystack.Grid.select">select</a></code></li>
<li><code><a title="shaystack.Grid.sort" href="#shaystack.Grid.sort">sort</a></code></li>
<li><code><a title="shaystack.Grid.version" href="#shaystack.Grid.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shaystack.HaystackInterface" href="#shaystack.HaystackInterface">HaystackInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="shaystack.HaystackInterface.about" href="#shaystack.HaystackInterface.about">about</a></code></li>
<li><code><a title="shaystack.HaystackInterface.formats" href="#shaystack.HaystackInterface.formats">formats</a></code></li>
<li><code><a title="shaystack.HaystackInterface.get_customer_id" href="#shaystack.HaystackInterface.get_customer_id">get_customer_id</a></code></li>
<li><code><a title="shaystack.HaystackInterface.get_tz" href="#shaystack.HaystackInterface.get_tz">get_tz</a></code></li>
<li><code><a title="shaystack.HaystackInterface.his_read" href="#shaystack.HaystackInterface.his_read">his_read</a></code></li>
<li><code><a title="shaystack.HaystackInterface.his_write" href="#shaystack.HaystackInterface.his_write">his_write</a></code></li>
<li><code><a title="shaystack.HaystackInterface.invoke_action" href="#shaystack.HaystackInterface.invoke_action">invoke_action</a></code></li>
<li><code><a title="shaystack.HaystackInterface.name" href="#shaystack.HaystackInterface.name">name</a></code></li>
<li><code><a title="shaystack.HaystackInterface.nav" href="#shaystack.HaystackInterface.nav">nav</a></code></li>
<li><code><a title="shaystack.HaystackInterface.ops" href="#shaystack.HaystackInterface.ops">ops</a></code></li>
<li><code><a title="shaystack.HaystackInterface.point_write_read" href="#shaystack.HaystackInterface.point_write_read">point_write_read</a></code></li>
<li><code><a title="shaystack.HaystackInterface.point_write_write" href="#shaystack.HaystackInterface.point_write_write">point_write_write</a></code></li>
<li><code><a title="shaystack.HaystackInterface.read" href="#shaystack.HaystackInterface.read">read</a></code></li>
<li><code><a title="shaystack.HaystackInterface.values_for_tag" href="#shaystack.HaystackInterface.values_for_tag">values_for_tag</a></code></li>
<li><code><a title="shaystack.HaystackInterface.versions" href="#shaystack.HaystackInterface.versions">versions</a></code></li>
<li><code><a title="shaystack.HaystackInterface.watch_poll" href="#shaystack.HaystackInterface.watch_poll">watch_poll</a></code></li>
<li><code><a title="shaystack.HaystackInterface.watch_sub" href="#shaystack.HaystackInterface.watch_sub">watch_sub</a></code></li>
<li><code><a title="shaystack.HaystackInterface.watch_unsub" href="#shaystack.HaystackInterface.watch_unsub">watch_unsub</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shaystack.MetadataObject" href="#shaystack.MetadataObject">MetadataObject</a></code></h4>
<ul class="">
<li><code><a title="shaystack.MetadataObject.append" href="#shaystack.MetadataObject.append">append</a></code></li>
<li><code><a title="shaystack.MetadataObject.copy" href="#shaystack.MetadataObject.copy">copy</a></code></li>
<li><code><a title="shaystack.MetadataObject.extend" href="#shaystack.MetadataObject.extend">extend</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shaystack.Quantity" href="#shaystack.Quantity">Quantity</a></code></h4>
</li>
<li>
<h4><code><a title="shaystack.Ref" href="#shaystack.Ref">Ref</a></code></h4>
<ul class="">
<li><code><a title="shaystack.Ref.has_value" href="#shaystack.Ref.has_value">has_value</a></code></li>
<li><code><a title="shaystack.Ref.name" href="#shaystack.Ref.name">name</a></code></li>
<li><code><a title="shaystack.Ref.value" href="#shaystack.Ref.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shaystack.Uri" href="#shaystack.Uri">Uri</a></code></h4>
</li>
<li>
<h4><code><a title="shaystack.Version" href="#shaystack.Version">Version</a></code></h4>
<ul class="">
<li><code><a title="shaystack.Version.nearest" href="#shaystack.Version.nearest">nearest</a></code></li>
<li><code><a title="shaystack.Version.version_extra" href="#shaystack.Version.version_extra">version_extra</a></code></li>
<li><code><a title="shaystack.Version.version_nums" href="#shaystack.Version.version_nums">version_nums</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shaystack.XStr" href="#shaystack.XStr">XStr</a></code></h4>
<ul class="">
<li><code><a title="shaystack.XStr.data" href="#shaystack.XStr.data">data</a></code></li>
<li><code><a title="shaystack.XStr.data_to_string" href="#shaystack.XStr.data_to_string">data_to_string</a></code></li>
<li><code><a title="shaystack.XStr.encoding" href="#shaystack.XStr.encoding">encoding</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>