<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shaystack.providers API documentation</title>
<meta name="description" content="Implementation of Haystack API" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shaystack.providers</code></h1>
</header>
<section id="section-intro">
<p>Implementation of Haystack API</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Haystack API Provider module
# See the accompanying LICENSE file.
# (C) 2021 Engie Digital
#
# vim: set ts=4 sts=4 et tw=78 sw=4 si:
&#34;&#34;&#34;
Implementation of Haystack API
&#34;&#34;&#34;

from .haystack_interface import HaystackInterface, get_provider
from ..grid import Grid

__all__ = [&#34;HaystackInterface&#34;, &#34;get_provider&#34;]

__pdoc__ = \
    {
        &#34;sqldb_protocol&#34;: False,
        &#34;db_postgres&#34;: False,
        &#34;db_sqlite&#34;: False,
        &#34;db_timestream&#34;: False,
        &#34;tools&#34;: False,
    }


def purge_grid(grid: Grid) -&gt; Grid:
    &#34;&#34;&#34;
    Purge all entity not in columns
    &#34;&#34;&#34;
    cols = grid.column
    new_grid = Grid(version=grid.version, metadata=grid.metadata, columns=cols)
    for row in grid:
        new_grid.append({key: val for key, val in row.items() if key in cols})
    return new_grid</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="shaystack.providers.athena" href="athena.html">shaystack.providers.athena</a></code></dt>
<dd>
<div class="desc"><p>Add the persistance of time-series with Athena database …</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.db" href="db.html">shaystack.providers.db</a></code></dt>
<dd>
<div class="desc"><p>An generic Haystack Read-Only API provider to expose an Haystack data via the Haystack API …</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.db_haystack_interface" href="db_haystack_interface.html">shaystack.providers.db_haystack_interface</a></code></dt>
<dd>
<div class="desc"><p>Private extension of haystack implementation to add the link with DB.</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.db_mongo" href="db_mongo.html">shaystack.providers.db_mongo</a></code></dt>
<dd>
<div class="desc"><p>Tools to convert haystack filter to mongo request</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.db_mysql" href="db_mysql.html">shaystack.providers.db_mysql</a></code></dt>
<dd>
<div class="desc"><p>Save Haystack ontology in SQLite database with JSon extension.
Convert the haystack filter to sqlite SQL equivalent syntax.</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.haystack_interface" href="haystack_interface.html">shaystack.providers.haystack_interface</a></code></dt>
<dd>
<div class="desc"><p>Base of haystack implementation.</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.import_db" href="import_db.html">shaystack.providers.import_db</a></code></dt>
<dd>
<div class="desc"><p>Import haystack file in SQL database.</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.mongodb" href="mongodb.html">shaystack.providers.mongodb</a></code></dt>
<dd>
<div class="desc"><p>Manipulate Haystack ontology on MongoDB database …</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.ping" href="ping.html">shaystack.providers.ping</a></code></dt>
<dd>
<div class="desc"><p>An Haystack API provider with a very simple implementation.
It's must be used for test.</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.repl_db" href="repl_db.html">shaystack.providers.repl_db</a></code></dt>
<dd>
<div class="desc"><p>User interface to print the translation between filter syntax to others syntaxes.</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.sql" href="sql.html">shaystack.providers.sql</a></code></dt>
<dd>
<div class="desc"><p>Manipulate Haystack ontology on SQL database …</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.timestream" href="timestream.html">shaystack.providers.timestream</a></code></dt>
<dd>
<div class="desc"><p>Add the persistance of time-series with TS database …</p></div>
</dd>
<dt><code class="name"><a title="shaystack.providers.url" href="url.html">shaystack.providers.url</a></code></dt>
<dd>
<div class="desc"><p>An Haystack Read-Only API provider to expose an Haystack file via the Haystack API.
The file must be referenced with the environment variable …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="shaystack.providers.get_provider"><code class="name flex">
<span>def <span class="ident">get_provider</span></span>(<span>class_str: str, envs: Dict[str, str]) ‑> <a title="shaystack.providers.haystack_interface.HaystackInterface" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the provider.
If the provider is an abstract class, create a sub class with all the implementation
and return an instance of this subclass. Then, the 'ops' method can analyse the current instance
and detect the implemented and abstract methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>class_str</code></strong></dt>
<dd>The name of the module that contains the provider.</dd>
<dt><strong><code>envs</code></strong></dt>
<dd>Environement variable (os.env ?)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A instance of this subclass if it exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_provider(class_str: str, envs: Dict[str, str],  # pylint: disable=protected-access
                 ) -&gt; HaystackInterface:
    &#34;&#34;&#34;Return an instance of the provider.
    If the provider is an abstract class, create a sub class with all the implementation
    and return an instance of this subclass. Then, the &#39;ops&#39; method can analyse the current instance
    and detect the implemented and abstract methods.

    Args:
        class_str: The name of the module that contains the provider.
        envs: Environement variable (os.env ?)

    Returns:
        A instance of this subclass if it exists
    &#34;&#34;&#34;
    if not class_str.endswith(&#34;.Provider&#34;):
        class_str += &#34;.Provider&#34;
    # if not no_cache(envs) and class_str in _providers:
    #     return _providers[class_str]
    module_path, class_name = class_str.rsplit(&#34;.&#34;, 1)
    module = import_module(module_path)
    # Get the abstract class name
    provider_class = getattr(module, class_name)

    # Implement all abstract method.
    # Then, it&#39;s possible to generate the Ops operator dynamically
    # pylint: disable=missing-function-docstring,useless-super-delegation
    # noinspection PyShadowingNames
    class FullInterface(provider_class):  # pylint: disable=missing-class-docstring
        def __init__(self, envs: Dict[str, str]):
            provider_class.__init__(self, envs)

        def name(self) -&gt; str:
            return super().name()

        def about(
                self, home: str
        ) -&gt; Grid:  # pylint: disable=missing-function-docstring,useless-super-delegation
            return super().about(home)

        def read(
                self,
                limit: int,
                select: Optional[str],
                entity_ids: Optional[List[Ref]],
                grid_filter: Optional[str],
                date_version: Optional[datetime],
        ) -&gt; Grid:
            # pylint: disable=missing-function-docstring,useless-super-delegation
            return super().read(limit, select, entity_ids, grid_filter, date_version)

        def nav(self, nav_id: str) -&gt; Any:
            # pylint: disable=missing-function-docstring,useless-super-delegation
            return super().nav(nav_id)

        def watch_sub(
                self,
                watch_dis: str,
                watch_id: Optional[str],
                ids: List[Ref],
                lease: Optional[int],
        ) -&gt; Grid:
            # pylint: disable=missing-function-docstring,useless-super-delegation
            return super().watch_sub(watch_dis, watch_id, ids, lease)

        def watch_unsub(
                self, watch_id: str, ids: List[Ref], close_all: bool
        ) -&gt; None:
            # pylint: disable=missing-function-docstring,useless-super-delegation
            return super().watch_unsub(watch_id, ids, close_all)

        def watch_poll(self, watch_id: str, refresh: bool) -&gt; Grid:
            return super().watch_poll(watch_id, refresh)

        def point_write_read(  # pylint: disable=missing-function-docstring,useless-super-delegation
                self, entity_id: Ref, date_version: Optional[datetime]
        ) -&gt; Grid:
            return super().point_write_read(entity_id, date_version)

        def point_write_write(  # pylint: disable=missing-function-docstring,useless-super-delegation
                self,
                entity_id: Ref,
                level: int,
                val: Optional[Any],
                duration: Quantity,
                who: Optional[str],
                date_version: Optional[datetime],
        ) -&gt; None:  # pylint: disable=no-self-use
            return super().point_write_write(
                entity_id, level, val, duration, who, date_version
            )

        def his_read(  # pylint: disable=missing-function-docstring,useless-super-delegation
                self,
                entity_id: Ref,
                date_range: Optional[Tuple[datetime, datetime]],
                date_version: Optional[datetime],
        ) -&gt; Grid:
            return super().his_read(entity_id, date_range, date_version)

        def his_write(  # pylint: disable=missing-function-docstring, useless-super-delegation
                self, entity_id: Ref, time_serie: Grid, date_version: Optional[datetime]
        ) -&gt; Grid:
            return super().his_write(entity_id, time_serie, date_version)

        def invoke_action(  # pylint: disable=missing-function-docstring,useless-super-delegation
                self,
                entity_id: Ref,
                action: str,
                params: Dict[str, Any],
        ) -&gt; Grid:
            return super().invoke_action(entity_id, action, params)

    _providers[class_str] = FullInterface(envs)
    return _providers[class_str]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shaystack.providers.HaystackInterface"><code class="flex name class">
<span>class <span class="ident">HaystackInterface</span></span>
<span>(</span><span>envs: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Interface to implement to be compatible with Haystack REST protocol.
The subclasses may be abstract (implemented only a part of methods),
the 'ops' code detect that, and can calculate the set of implemented operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HaystackInterface(ABC):
    &#34;&#34;&#34;
    Interface to implement to be compatible with Haystack REST protocol.
    The subclasses may be abstract (implemented only a part of methods),
    the &#39;ops&#39; code detect that, and can calculate the set of implemented operations.
    &#34;&#34;&#34;
    __slots__ = [&#39;_envs&#39;]

    def __init__(self, envs: Dict[str, str]):
        assert envs is not None
        self._envs = envs

    @property
    @abstractmethod
    def name(self) -&gt; str:
        &#34;&#34;&#34; The name of the provider. &#34;&#34;&#34;
        raise NotImplementedError()

    def __repr__(self) -&gt; str:
        return self.name

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        pass

    # noinspection PyMethodMayBeStatic
    def get_tz(self) -&gt; BaseTzInfo:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Return server time zone. &#34;&#34;&#34;
        return get_localzone()

    def get_customer_id(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Override this for multi-tenant.
        May be, extract the customer id from the current `Principal`.
        &#34;&#34;&#34;
        return &#39;&#39;

    def values_for_tag(self, tag: str,
                       date_version: Optional[datetime] = None) -&gt; List[Any]:
        &#34;&#34;&#34;Get all values for a given tag.

        Args:
            tag: The tag to analyse.
            date_version: version date of the ontology.

        Returns:
            All unique values for a specific tag
        &#34;&#34;&#34;
        raise NotImplementedError()

    def versions(self) -&gt; List[datetime]:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Return a list of versions fot the current ontology.
        Returns:
            datetime for each version or empty array if unknown
        &#34;&#34;&#34;
        return []

    @abstractmethod
    def about(self, home: str) -&gt; Grid:
        &#34;&#34;&#34;Implement the Haystack &#39;about&#39; ops.

        The subclasse must complet the result with &#34;productUri&#34;, &#34;productVersion&#34;, &#34;moduleName&#34;
        and &#34;moduleVersion&#34;

        Args:
            home: Home url of the API

        Returns:
            The default &#39;about&#39; grid.
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns=[
                &#34;haystackVersion&#34;,  # Str version of REST implementation
                &#34;tz&#34;,  # Str of server&#39;s default timezone
                &#34;serverName&#34;,  # Str name of the server or project database
                &#34;serverTime&#34;,
                &#34;serverBootTime&#34;,
                &#34;productName&#34;,  # Str name of the server software product
                &#34;productUri&#34;,
                &#34;productVersion&#34;,
                # module which implements Haystack server protocol
                &#34;moduleName&#34;,
                # if its a plug-in to the product
                &#34;moduleVersion&#34;  # Str version of moduleName
            ],
        )
        grid.append(
            {
                &#34;haystackVersion&#34;: str(VER_3_0),
                &#34;tz&#34;: str(self.get_tz()),
                &#34;serverName&#34;: &#34;haystack_&#34; + self._envs.get(&#34;AWS_REGION&#34;, &#34;local&#34;),
                &#34;serverTime&#34;: datetime.now(tz=self.get_tz()).replace(microsecond=0),
                &#34;serverBootTime&#34;: datetime.now(tz=self.get_tz()).replace(
                    microsecond=0
                ),
                &#34;productName&#34;: &#34;Haystack Provider&#34;,
                &#34;productUri&#34;: Uri(home),
                &#34;productVersion&#34;: &#34;0.1&#34;,
                &#34;moduleName&#34;: &#34;AbstractProvider&#34;,
                &#34;moduleVersion&#34;: &#34;0.1&#34;,
            }
        )
        return grid

    # noinspection PyUnresolvedReferences
    def ops(self) -&gt; Grid:
        &#34;&#34;&#34; Implement the Haystack &#39;ops&#39; ops.

        Notes:
            Automatically calculate the implemented version.

        Returns:
            A Grid containing &#39;ops&#39; name operations and its related description
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns={
                &#34;name&#34;: {},
                &#34;summary&#34;: {},
            },
        )
        all_haystack_ops = {
            &#34;about&#34;: &#34;Summary information for server&#34;,
            &#34;ops&#34;: &#34;Operations supported by this server&#34;,
            &#34;formats&#34;: &#34;Grid data formats supported by this server&#34;,
            &#34;read&#34;: &#34;The read op is used to read a set of entity records either by their unique &#34;
                    &#34;identifier or using a filter.&#34;,
            &#34;nav&#34;: &#34;The nav op is used navigate a project for learning and discovery&#34;,
            &#34;watch_sub&#34;: &#34;The watch_sub operation is used to create new watches &#34;
                         &#34;or add entities to an existing watch.&#34;,
            &#34;watch_unsub&#34;: &#34;The watch_unsub operation is used to close a watch entirely &#34;
                           &#34;or remove entities from a watch.&#34;,
            &#34;watch_poll&#34;: &#34;The watch_poll operation is used to poll a watch for &#34;
                          &#34;changes to the subscribed entity records.&#34;,
            &#34;point_write&#34;: &#34;The point_write_read op is used to: read the current status of a &#34;
                           &#34;writable point&#39;s priority array &#34;
                           &#34;or write to a given level&#34;,
            &#34;his_read&#34;: &#34;The his_read op is used to read a time-series data &#34;
                        &#34;from historized point.&#34;,
            &#34;his_write&#34;: &#34;The his_write op is used to post new time-series &#34;
                         &#34;data to a historized point.&#34;,
            &#34;invoke_action&#34;: &#34;The invoke_action op is used to invoke a &#34;
                             &#34;user action on a target record.&#34;,
        }
        # Remove abstract method
        # noinspection PyUnresolvedReferences
        for abstract_method in self.__class__.__base__.__abstractmethods__:
            all_haystack_ops.pop(abstract_method, None)
        if (
                &#34;point_write_read&#34; in self.__class__.__base__.__abstractmethods__
                or &#34;point_write_write&#34; in self.__class__.__base__.__abstractmethods__
        ):
            all_haystack_ops.pop(&#34;point_write&#34;, None)
        all_haystack_ops = {_to_camel(k): v for k, v in all_haystack_ops.items()}

        grid.extend(
            [
                {&#34;name&#34;: name, &#34;summary&#34;: summary}
                for name, summary in all_haystack_ops.items()
            ]
        )
        return grid

    def formats(self) -&gt; Optional[Grid]:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;formats&#39; ops.

        Notes:
            Implement this method, only if you want to limit the format negotiation
        Returns:
            The grid format or None. If None, the API accept all formats ZINC, TRIO, JSON and CSV.
        &#34;&#34;&#34;
        return None  # type: ignore

    @abstractmethod
    def read(
            self,
            limit: int,
            select: Optional[str],
            entity_ids: Optional[List[Ref]],
            grid_filter: Optional[str],
            date_version: Optional[datetime],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;read&#39; ops.

        Args:
            limit: The number of record to return or zero
            select: The selected tag separated with comma, else &#39;&#39; or &#39;*&#39;
            entity_ids: A list en ids. If set, grid_filter and limit are ignored.
            grid_filter: A filter to apply. Ignored if entity_ids is set.
            date_version: The date of the ontology version.

        Returns:
            The requested Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def nav(self, nav_id: str) -&gt; Any:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;nav&#39; ops.
        This operation allows servers to expose the database in a human-friendly tree (or graph)
        that can be explored

        Args:
             nav_id: The string for nav id column
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_sub(
            self,
            watch_dis: str,
            watch_id: Optional[str],
            ids: List[Ref],
            lease: Optional[int],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchSub&#39; ops.

        Args:
            watch_dis: Watch description
            watch_id: The user watch_id to update or None.
            ids: The list of ids to watch.
            lease: Lease to apply.

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_unsub(
            self, watch_id: str, ids: List[Ref], close: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchUnsub&#39; ops.

        Args:
            watch_id: The user watch_id to update or None
            ids: The list of ids to watch
            close: Set to True to close

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_poll(
            self, watch_id: str, refresh: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;watchPoll&#39; ops.

        Args:
            watch_id: The user watch_id to update or None
            refresh: Set to True for refreshing the data

        Returns:
            A Grid where each row corresponds to a watched entity.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_read(
            self, entity_id: Ref, date_version: Optional[datetime]
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

        Args:
            entity_id: The entity to update
            date_version: The optional date version to update

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_write(
            self,
            entity_id: Ref,
            level: int,
            val: Optional[Any],
            duration: Quantity,
            who: Optional[str],
            date_version: Optional[datetime] = None,
    ) -&gt; None:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

        Args:
            entity_id: The entity to update
            level: Number from 1-17 for level to write
            val: Value to write or null to auto the level
            duration: Number with duration unit if setting level 8
            who: Optional username performing the write, otherwise user dis is used
            date_version: The optional date version to update

        Returns:
            None
        &#34;&#34;&#34;
        raise NotImplementedError()

    # Date dates_range must be:
    # &#34;today&#34;
    # &#34;yesterday&#34;
    # &#34;{date}&#34;
    # &#34;{date},{date}&#34;
    # &#34;{dateTime},{dateTime}&#34;
    # &#34;{dateTime}&#34;
    @abstractmethod
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Tuple[datetime, datetime],
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisRead&#39; ops.

        Args:
            entity_id: The entity to read
            dates_range: May be &#34;today&#34;, &#34;yesterday&#34;, {date}, ({date},{date}), ({datetime},{datetime}),
            {dateTime}
            date_version: The optional date version to read

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def his_write(
            self,
            entity_id: Ref,
            time_series: Grid,
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisWrite&#39; ops.

        Args:
            entity_id: The entity to read
            time_series: A grid with a time series
            date_version: The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def invoke_action(
            self,
            entity_id: Ref,
            action: str,
            params: Dict[str, Any],
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;invokeAction&#39; ops.

        Args:
            entity_id: The entity to read
            action: The action string
            params: A dictionary with parameters
            date_version: The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface">DBHaystackInterface</a></li>
<li><a title="shaystack.providers.ping.Provider" href="ping.html#shaystack.providers.ping.Provider">Provider</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="shaystack.providers.HaystackInterface.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The name of the provider.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def name(self) -&gt; str:
    &#34;&#34;&#34; The name of the provider. &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="shaystack.providers.HaystackInterface.about"><code class="name flex">
<span>def <span class="ident">about</span></span>(<span>self, home: str) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'about' ops.</p>
<p>The subclasse must complet the result with "productUri", "productVersion", "moduleName"
and "moduleVersion"</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>home</code></strong></dt>
<dd>Home url of the API</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The default 'about' grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def about(self, home: str) -&gt; Grid:
    &#34;&#34;&#34;Implement the Haystack &#39;about&#39; ops.

    The subclasse must complet the result with &#34;productUri&#34;, &#34;productVersion&#34;, &#34;moduleName&#34;
    and &#34;moduleVersion&#34;

    Args:
        home: Home url of the API

    Returns:
        The default &#39;about&#39; grid.
    &#34;&#34;&#34;
    grid = Grid(
        version=VER_3_0,
        columns=[
            &#34;haystackVersion&#34;,  # Str version of REST implementation
            &#34;tz&#34;,  # Str of server&#39;s default timezone
            &#34;serverName&#34;,  # Str name of the server or project database
            &#34;serverTime&#34;,
            &#34;serverBootTime&#34;,
            &#34;productName&#34;,  # Str name of the server software product
            &#34;productUri&#34;,
            &#34;productVersion&#34;,
            # module which implements Haystack server protocol
            &#34;moduleName&#34;,
            # if its a plug-in to the product
            &#34;moduleVersion&#34;  # Str version of moduleName
        ],
    )
    grid.append(
        {
            &#34;haystackVersion&#34;: str(VER_3_0),
            &#34;tz&#34;: str(self.get_tz()),
            &#34;serverName&#34;: &#34;haystack_&#34; + self._envs.get(&#34;AWS_REGION&#34;, &#34;local&#34;),
            &#34;serverTime&#34;: datetime.now(tz=self.get_tz()).replace(microsecond=0),
            &#34;serverBootTime&#34;: datetime.now(tz=self.get_tz()).replace(
                microsecond=0
            ),
            &#34;productName&#34;: &#34;Haystack Provider&#34;,
            &#34;productUri&#34;: Uri(home),
            &#34;productVersion&#34;: &#34;0.1&#34;,
            &#34;moduleName&#34;: &#34;AbstractProvider&#34;,
            &#34;moduleVersion&#34;: &#34;0.1&#34;,
        }
    )
    return grid</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.formats"><code class="name flex">
<span>def <span class="ident">formats</span></span>(<span>self) ‑> Union[shaystack.grid.Grid, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'formats' ops.</p>
<h2 id="notes">Notes</h2>
<p>Implement this method, only if you want to limit the format negotiation</p>
<h2 id="returns">Returns</h2>
<p>The grid format or None. If None, the API accept all formats ZINC, TRIO, JSON and CSV.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats(self) -&gt; Optional[Grid]:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;formats&#39; ops.

    Notes:
        Implement this method, only if you want to limit the format negotiation
    Returns:
        The grid format or None. If None, the API accept all formats ZINC, TRIO, JSON and CSV.
    &#34;&#34;&#34;
    return None  # type: ignore</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.get_customer_id"><code class="name flex">
<span>def <span class="ident">get_customer_id</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Override this for multi-tenant.
May be, extract the customer id from the current <code>Principal</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_customer_id(self) -&gt; str:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Override this for multi-tenant.
    May be, extract the customer id from the current `Principal`.
    &#34;&#34;&#34;
    return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.get_tz"><code class="name flex">
<span>def <span class="ident">get_tz</span></span>(<span>self) ‑> pytz.tzinfo.BaseTzInfo</span>
</code></dt>
<dd>
<div class="desc"><p>Return server time zone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tz(self) -&gt; BaseTzInfo:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Return server time zone. &#34;&#34;&#34;
    return get_localzone()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.his_read"><code class="name flex">
<span>def <span class="ident">his_read</span></span>(<span>self, entity_id: shaystack.datatypes.Ref, dates_range: Tuple[datetime.datetime, datetime.datetime], date_version: Union[datetime.datetime, NoneType] = None) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'hisRead' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to read</dd>
<dt><strong><code>dates_range</code></strong></dt>
<dd>May be "today", "yesterday", {date}, ({date},{date}), ({datetime},{datetime}),</dd>
<dt>{dateTime}</dt>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def his_read(
        self,
        entity_id: Ref,
        dates_range: Tuple[datetime, datetime],
        date_version: Optional[datetime] = None,
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;hisRead&#39; ops.

    Args:
        entity_id: The entity to read
        dates_range: May be &#34;today&#34;, &#34;yesterday&#34;, {date}, ({date},{date}), ({datetime},{datetime}),
        {dateTime}
        date_version: The optional date version to read

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.his_write"><code class="name flex">
<span>def <span class="ident">his_write</span></span>(<span>self, entity_id: shaystack.datatypes.Ref, time_series: shaystack.grid.Grid, date_version: Union[datetime.datetime, NoneType] = None) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'hisWrite' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to read</dd>
<dt><strong><code>time_series</code></strong></dt>
<dd>A grid with a time series</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def his_write(
        self,
        entity_id: Ref,
        time_series: Grid,
        date_version: Optional[datetime] = None
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;hisWrite&#39; ops.

    Args:
        entity_id: The entity to read
        time_series: A grid with a time series
        date_version: The optional date version to update

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.invoke_action"><code class="name flex">
<span>def <span class="ident">invoke_action</span></span>(<span>self, entity_id: shaystack.datatypes.Ref, action: str, params: Dict[str, Any], date_version: Union[datetime.datetime, NoneType] = None) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'invokeAction' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to read</dd>
<dt><strong><code>action</code></strong></dt>
<dd>The action string</dd>
<dt><strong><code>params</code></strong></dt>
<dd>A dictionary with parameters</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def invoke_action(
        self,
        entity_id: Ref,
        action: str,
        params: Dict[str, Any],
        date_version: Optional[datetime] = None
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;invokeAction&#39; ops.

    Args:
        entity_id: The entity to read
        action: The action string
        params: A dictionary with parameters
        date_version: The optional date version to update

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.nav"><code class="name flex">
<span>def <span class="ident">nav</span></span>(<span>self, nav_id: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'nav' ops.
This operation allows servers to expose the database in a human-friendly tree (or graph)
that can be explored</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nav_id</code></strong></dt>
<dd>The string for nav id column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def nav(self, nav_id: str) -&gt; Any:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;nav&#39; ops.
    This operation allows servers to expose the database in a human-friendly tree (or graph)
    that can be explored

    Args:
         nav_id: The string for nav id column
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.ops"><code class="name flex">
<span>def <span class="ident">ops</span></span>(<span>self) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'ops' ops.</p>
<h2 id="notes">Notes</h2>
<p>Automatically calculate the implemented version.</p>
<h2 id="returns">Returns</h2>
<p>A Grid containing 'ops' name operations and its related description</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ops(self) -&gt; Grid:
    &#34;&#34;&#34; Implement the Haystack &#39;ops&#39; ops.

    Notes:
        Automatically calculate the implemented version.

    Returns:
        A Grid containing &#39;ops&#39; name operations and its related description
    &#34;&#34;&#34;
    grid = Grid(
        version=VER_3_0,
        columns={
            &#34;name&#34;: {},
            &#34;summary&#34;: {},
        },
    )
    all_haystack_ops = {
        &#34;about&#34;: &#34;Summary information for server&#34;,
        &#34;ops&#34;: &#34;Operations supported by this server&#34;,
        &#34;formats&#34;: &#34;Grid data formats supported by this server&#34;,
        &#34;read&#34;: &#34;The read op is used to read a set of entity records either by their unique &#34;
                &#34;identifier or using a filter.&#34;,
        &#34;nav&#34;: &#34;The nav op is used navigate a project for learning and discovery&#34;,
        &#34;watch_sub&#34;: &#34;The watch_sub operation is used to create new watches &#34;
                     &#34;or add entities to an existing watch.&#34;,
        &#34;watch_unsub&#34;: &#34;The watch_unsub operation is used to close a watch entirely &#34;
                       &#34;or remove entities from a watch.&#34;,
        &#34;watch_poll&#34;: &#34;The watch_poll operation is used to poll a watch for &#34;
                      &#34;changes to the subscribed entity records.&#34;,
        &#34;point_write&#34;: &#34;The point_write_read op is used to: read the current status of a &#34;
                       &#34;writable point&#39;s priority array &#34;
                       &#34;or write to a given level&#34;,
        &#34;his_read&#34;: &#34;The his_read op is used to read a time-series data &#34;
                    &#34;from historized point.&#34;,
        &#34;his_write&#34;: &#34;The his_write op is used to post new time-series &#34;
                     &#34;data to a historized point.&#34;,
        &#34;invoke_action&#34;: &#34;The invoke_action op is used to invoke a &#34;
                         &#34;user action on a target record.&#34;,
    }
    # Remove abstract method
    # noinspection PyUnresolvedReferences
    for abstract_method in self.__class__.__base__.__abstractmethods__:
        all_haystack_ops.pop(abstract_method, None)
    if (
            &#34;point_write_read&#34; in self.__class__.__base__.__abstractmethods__
            or &#34;point_write_write&#34; in self.__class__.__base__.__abstractmethods__
    ):
        all_haystack_ops.pop(&#34;point_write&#34;, None)
    all_haystack_ops = {_to_camel(k): v for k, v in all_haystack_ops.items()}

    grid.extend(
        [
            {&#34;name&#34;: name, &#34;summary&#34;: summary}
            for name, summary in all_haystack_ops.items()
        ]
    )
    return grid</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.point_write_read"><code class="name flex">
<span>def <span class="ident">point_write_read</span></span>(<span>self, entity_id: shaystack.datatypes.Ref, date_version: Union[datetime.datetime, NoneType]) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'pointWrite' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to update</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def point_write_read(
        self, entity_id: Ref, date_version: Optional[datetime]
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

    Args:
        entity_id: The entity to update
        date_version: The optional date version to update

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.point_write_write"><code class="name flex">
<span>def <span class="ident">point_write_write</span></span>(<span>self, entity_id: shaystack.datatypes.Ref, level: int, val: Union[Any, NoneType], duration: shaystack.datatypes.Quantity, who: Union[str, NoneType], date_version: Union[datetime.datetime, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'pointWrite' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong></dt>
<dd>The entity to update</dd>
<dt><strong><code>level</code></strong></dt>
<dd>Number from 1-17 for level to write</dd>
<dt><strong><code>val</code></strong></dt>
<dd>Value to write or null to auto the level</dd>
<dt><strong><code>duration</code></strong></dt>
<dd>Number with duration unit if setting level 8</dd>
<dt><strong><code>who</code></strong></dt>
<dd>Optional username performing the write, otherwise user dis is used</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def point_write_write(
        self,
        entity_id: Ref,
        level: int,
        val: Optional[Any],
        duration: Quantity,
        who: Optional[str],
        date_version: Optional[datetime] = None,
) -&gt; None:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops.

    Args:
        entity_id: The entity to update
        level: Number from 1-17 for level to write
        val: Value to write or null to auto the level
        duration: Number with duration unit if setting level 8
        who: Optional username performing the write, otherwise user dis is used
        date_version: The optional date version to update

    Returns:
        None
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, limit: int, select: Union[str, NoneType], entity_ids: Union[List[shaystack.datatypes.Ref], NoneType], grid_filter: Union[str, NoneType], date_version: Union[datetime.datetime, NoneType]) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'read' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong></dt>
<dd>The number of record to return or zero</dd>
<dt><strong><code>select</code></strong></dt>
<dd>The selected tag separated with comma, else '' or '*'</dd>
<dt><strong><code>entity_ids</code></strong></dt>
<dd>A list en ids. If set, grid_filter and limit are ignored.</dd>
<dt><strong><code>grid_filter</code></strong></dt>
<dd>A filter to apply. Ignored if entity_ids is set.</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>The date of the ontology version.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(
        self,
        limit: int,
        select: Optional[str],
        entity_ids: Optional[List[Ref]],
        grid_filter: Optional[str],
        date_version: Optional[datetime],
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;read&#39; ops.

    Args:
        limit: The number of record to return or zero
        select: The selected tag separated with comma, else &#39;&#39; or &#39;*&#39;
        entity_ids: A list en ids. If set, grid_filter and limit are ignored.
        grid_filter: A filter to apply. Ignored if entity_ids is set.
        date_version: The date of the ontology version.

    Returns:
        The requested Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.values_for_tag"><code class="name flex">
<span>def <span class="ident">values_for_tag</span></span>(<span>self, tag: str, date_version: Union[datetime.datetime, NoneType] = None) ‑> List[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all values for a given tag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong></dt>
<dd>The tag to analyse.</dd>
<dt><strong><code>date_version</code></strong></dt>
<dd>version date of the ontology.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>All unique values for a specific tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values_for_tag(self, tag: str,
                   date_version: Optional[datetime] = None) -&gt; List[Any]:
    &#34;&#34;&#34;Get all values for a given tag.

    Args:
        tag: The tag to analyse.
        date_version: version date of the ontology.

    Returns:
        All unique values for a specific tag
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.versions"><code class="name flex">
<span>def <span class="ident">versions</span></span>(<span>self) ‑> List[datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of versions fot the current ontology.</p>
<h2 id="returns">Returns</h2>
<p>datetime for each version or empty array if unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def versions(self) -&gt; List[datetime]:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Return a list of versions fot the current ontology.
    Returns:
        datetime for each version or empty array if unknown
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.watch_poll"><code class="name flex">
<span>def <span class="ident">watch_poll</span></span>(<span>self, watch_id: str, refresh: bool) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchPoll' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_id</code></strong></dt>
<dd>The user watch_id to update or None</dd>
<dt><strong><code>refresh</code></strong></dt>
<dd>Set to True for refreshing the data</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid where each row corresponds to a watched entity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_poll(
        self, watch_id: str, refresh: bool
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;watchPoll&#39; ops.

    Args:
        watch_id: The user watch_id to update or None
        refresh: Set to True for refreshing the data

    Returns:
        A Grid where each row corresponds to a watched entity.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.watch_sub"><code class="name flex">
<span>def <span class="ident">watch_sub</span></span>(<span>self, watch_dis: str, watch_id: Union[str, NoneType], ids: List[shaystack.datatypes.Ref], lease: Union[int, NoneType]) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchSub' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_dis</code></strong></dt>
<dd>Watch description</dd>
<dt><strong><code>watch_id</code></strong></dt>
<dd>The user watch_id to update or None.</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>The list of ids to watch.</dd>
<dt><strong><code>lease</code></strong></dt>
<dd>Lease to apply.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_sub(
        self,
        watch_dis: str,
        watch_id: Optional[str],
        ids: List[Ref],
        lease: Optional[int],
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;watchSub&#39; ops.

    Args:
        watch_dis: Watch description
        watch_id: The user watch_id to update or None.
        ids: The list of ids to watch.
        lease: Lease to apply.

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.HaystackInterface.watch_unsub"><code class="name flex">
<span>def <span class="ident">watch_unsub</span></span>(<span>self, watch_id: str, ids: List[shaystack.datatypes.Ref], close: bool) ‑> shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchUnsub' ops.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_id</code></strong></dt>
<dd>The user watch_id to update or None</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>The list of ids to watch</dd>
<dt><strong><code>close</code></strong></dt>
<dd>Set to True to close</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_unsub(
        self, watch_id: str, ids: List[Ref], close: bool
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;watchUnsub&#39; ops.

    Args:
        watch_id: The user watch_id to update or None
        ids: The list of ids to watch
        close: Set to True to close

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shaystack" href="../index.html">shaystack</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="shaystack.providers.athena" href="athena.html">shaystack.providers.athena</a></code></li>
<li><code><a title="shaystack.providers.db" href="db.html">shaystack.providers.db</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface" href="db_haystack_interface.html">shaystack.providers.db_haystack_interface</a></code></li>
<li><code><a title="shaystack.providers.db_mongo" href="db_mongo.html">shaystack.providers.db_mongo</a></code></li>
<li><code><a title="shaystack.providers.db_mysql" href="db_mysql.html">shaystack.providers.db_mysql</a></code></li>
<li><code><a title="shaystack.providers.haystack_interface" href="haystack_interface.html">shaystack.providers.haystack_interface</a></code></li>
<li><code><a title="shaystack.providers.import_db" href="import_db.html">shaystack.providers.import_db</a></code></li>
<li><code><a title="shaystack.providers.mongodb" href="mongodb.html">shaystack.providers.mongodb</a></code></li>
<li><code><a title="shaystack.providers.ping" href="ping.html">shaystack.providers.ping</a></code></li>
<li><code><a title="shaystack.providers.repl_db" href="repl_db.html">shaystack.providers.repl_db</a></code></li>
<li><code><a title="shaystack.providers.sql" href="sql.html">shaystack.providers.sql</a></code></li>
<li><code><a title="shaystack.providers.timestream" href="timestream.html">shaystack.providers.timestream</a></code></li>
<li><code><a title="shaystack.providers.url" href="url.html">shaystack.providers.url</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="shaystack.providers.get_provider" href="#shaystack.providers.get_provider">get_provider</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shaystack.providers.HaystackInterface" href="#shaystack.providers.HaystackInterface">HaystackInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="shaystack.providers.HaystackInterface.about" href="#shaystack.providers.HaystackInterface.about">about</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.formats" href="#shaystack.providers.HaystackInterface.formats">formats</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.get_customer_id" href="#shaystack.providers.HaystackInterface.get_customer_id">get_customer_id</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.get_tz" href="#shaystack.providers.HaystackInterface.get_tz">get_tz</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.his_read" href="#shaystack.providers.HaystackInterface.his_read">his_read</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.his_write" href="#shaystack.providers.HaystackInterface.his_write">his_write</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.invoke_action" href="#shaystack.providers.HaystackInterface.invoke_action">invoke_action</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.name" href="#shaystack.providers.HaystackInterface.name">name</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.nav" href="#shaystack.providers.HaystackInterface.nav">nav</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.ops" href="#shaystack.providers.HaystackInterface.ops">ops</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.point_write_read" href="#shaystack.providers.HaystackInterface.point_write_read">point_write_read</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.point_write_write" href="#shaystack.providers.HaystackInterface.point_write_write">point_write_write</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.read" href="#shaystack.providers.HaystackInterface.read">read</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.values_for_tag" href="#shaystack.providers.HaystackInterface.values_for_tag">values_for_tag</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.versions" href="#shaystack.providers.HaystackInterface.versions">versions</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.watch_poll" href="#shaystack.providers.HaystackInterface.watch_poll">watch_poll</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.watch_sub" href="#shaystack.providers.HaystackInterface.watch_sub">watch_sub</a></code></li>
<li><code><a title="shaystack.providers.HaystackInterface.watch_unsub" href="#shaystack.providers.HaystackInterface.watch_unsub">watch_unsub</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>