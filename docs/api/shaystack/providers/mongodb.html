<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shaystack.providers.mongodb API documentation</title>
<meta name="description" content="Manipulate Haystack ontology on MongoDB database â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shaystack.providers.mongodb</code></h1>
</header>
<section id="section-intro">
<p>Manipulate Haystack ontology on MongoDB database.</p>
<p>Set the HAYSTACK_DB with mongo database connection URL
May be:
- mongodb+srv://localhost/?w=majority&amp;wtimeoutMS=2500#haystack</p>
<p>Each entity was save in one Mongo document. A column save the JSON version of entity.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# SQL Provider
# See the accompanying LICENSE file.
# (C) 2021 Engie Digital
#
# vim: set ts=4 sts=4 et tw=78 sw=4 si:
# pylint: disable=line-too-long
&#34;&#34;&#34;
Manipulate Haystack ontology on MongoDB database.

Set the HAYSTACK_DB with mongo database connection URL
May be:
- mongodb+srv://localhost/?w=majority&amp;wtimeoutMS=2500#haystack

Each entity was save in one Mongo document. A column save the JSON version of entity.
&#34;&#34;&#34;
import logging
from datetime import datetime, timedelta
from os.path import dirname
from typing import Optional, List, Any, Tuple, Dict, cast
from urllib.parse import urlparse, urlunparse

import pytz
from overrides import overrides
from pymongo import MongoClient, ASCENDING
from pymongo.collection import Collection
from pymongo.database import Database

from .db_haystack_interface import DBHaystackInterface
from .db_mongo import _mongo_filter as mongo_filter
from .tools import _BOTO3_AVAILABLE, get_secret_manager_secret
from .url import read_grid_from_uri
from .. import Entity, LATEST_VER, re
from ..datatypes import Ref
from ..grid import Grid
from ..jsondumper import dump_scalar as json_dump_scalar, _dump_meta, _dump_columns
from ..jsonparser import parse_scalar as json_parse_scalar, _parse_metadata, _parse_cols

log = logging.getLogger(&#34;sql.Provider&#34;)

_END_OF_WORLD = datetime.max.replace(tzinfo=pytz.UTC)


def _conv_entity_to_row(entity: Entity) -&gt; Dict[str, Any]:
    return {k: json_dump_scalar(v)[1:-1] for k, v in entity.items()}


def _conv_row_to_entity(row: Dict[str, Any]) -&gt; Entity:
    return {k: json_parse_scalar(v) for k, v in row.items()}


# noinspection PyPep8,PyPep8,PyPep8,PyPep8
class Provider(DBHaystackInterface):
    &#34;&#34;&#34;
    Expose an Haystack data via the Haystack Rest API and SQL databases
    &#34;&#34;&#34;
    __slots__ = &#39;_connect&#39;, &#39;_client&#39;, &#39;_parsed_db&#39;, &#39;_table_name&#39;, &#39;_envs&#39;, &#39;_db_url&#39;

    def __init__(self, envs: Dict[str, str]):
        DBHaystackInterface.__init__(self, envs)
        self._connect = None
        self._client = None
        self._table_name = None
        self._db_url = self._envs[&#34;HAYSTACK_DB&#34;]
        log.info(&#34;Use %s&#34;, self._get_db())
        self._parsed_db = urlparse(self._get_db())

        table_name = self._parsed_db.fragment
        if not table_name:
            table_name = &#34;haystack&#34;
        else:
            parts = list(self._parsed_db)
            self._db_url = urlunparse(parts[:-1] + [&#39;&#39;])  # Remove fragment
            self._parsed_db = urlparse(self._db_url)
        self._table_name = table_name

        password = self._parsed_db.password
        if _BOTO3_AVAILABLE and self._parsed_db.username and \
                password.startswith(&#34;&lt;&#34;) and password.endswith(&#34;&gt;&#34;):
            password = get_secret_manager_secret(password[1:-1], self._envs)
            parts = list(self._parsed_db)
            user, _, host = re.split(&#39;[:|@]&#39;, parts[1])
            parts[1] = f&#34;{user}:{password}@{host}&#34;
            self._db_url = urlunparse(parts)
            self._parsed_db = urlparse(urlunparse(parts))

    def _get_db(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Return the url to the file to expose. &#34;&#34;&#34;
        return self._db_url

    @property
    def name(self) -&gt; str:
        return &#34;MongoDB&#34;

    @overrides
    def values_for_tag(self, tag: str,
                       date_version: Optional[datetime] = None) -&gt; List[Any]:
        return sorted([
            json_parse_scalar(val)
            for val in self.get_collection().distinct(
                f&#34;entity.{tag}&#34;,
                {
                    &#34;customer_id&#34;: self.get_customer_id()
                }
            )])

    @overrides
    def versions(self) -&gt; List[datetime]:
        &#34;&#34;&#34;
        Return datetime for each versions or empty array if is unknown
        &#34;&#34;&#34;
        return sorted(self.get_collection().distinct(
            &#34;start_datetime&#34;,
            {
                &#34;customer_id&#34;: self.get_customer_id()
            }
        ))

    @overrides
    def about(self, home: str) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;about&#39; operation &#34;&#34;&#34;
        grid = super().about(home)
        about_data = cast(Entity, grid[0])
        about_data.update(
            {  # pylint: disable=no-member
                &#34;productVersion&#34;: &#34;1.0&#34;,
                &#34;moduleName&#34;: &#34;MongoProvider&#34;,
                &#34;moduleVersion&#34;: &#34;1.0&#34;,
            }
        )
        return grid

    @overrides
    def read(
            self,
            limit: int,
            select: Optional[str],
            entity_ids: Optional[List[Ref]] = None,
            grid_filter: Optional[str] = None,
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:
        &#34;&#34;&#34; Implement Haystack &#39;read&#39; &#34;&#34;&#34;
        log.debug(
            &#34;----&gt; Call read(limit=%s, select=&#39;%s&#39;, ids=%s grid_filter=&#39;%s&#39; date_version=%s)&#34;,
            repr(limit),
            repr(select),
            repr(entity_ids),
            repr(grid_filter),
            repr(date_version),
        )
        if date_version is None:
            date_version = datetime.now().replace(tzinfo=pytz.UTC)

        if entity_ids is None:
            cursor = self.get_collection().aggregate(
                mongo_filter(grid_filter, date_version, limit, self.get_customer_id())
            )

            grid = self._init_grid_from_db(date_version)
            for row in cursor:
                grid.append(_conv_row_to_entity(row))
            return grid.select(select)

        customer_id = self.get_customer_id()
        cursor = self.get_collection().aggregate(
            [
                {&#39;$match&#39;: {&#39;customer_id&#39;: customer_id,
                            &#39;start_datetime&#39;: {&#39;$lte&#39;: date_version},
                            &#39;end_datetime&#39;: {&#39;$gt&#39;: date_version}}},
                {&#39;$replaceRoot&#39;: {&#39;newRoot&#39;: &#39;$entity&#39;}},
                {
                    &#39;$match&#39;: {
                        &#39;$expr&#39;: {
                            &#39;$in&#39;: [
                                {
                                    &#39;$let&#39;: {
                                        &#39;vars&#39;: {&#39;id_regex_&#39;:
                                            {
                                                &#39;$regexFind&#39;: {
                                                    &#39;input&#39;: &#39;$id&#39;,
                                                    &#39;regex&#39;: &#39;r:([:.~a-zA-Z0-9_-]+)&#39;
                                                }
                                            }
                                        },
                                        &#39;in&#39;: {&#39;$arrayElemAt&#39;: [&#39;$$id_regex_.captures&#39;, 0]}
                                    }
                                },
                                [ref.name for ref in entity_ids]
                            ]
                        }
                    }
                },
            ]
        )

        grid = self._init_grid_from_db(date_version)
        for row in cursor:
            grid.append(_conv_row_to_entity(row))
        return grid.select(select)

    @overrides
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Optional[Tuple[datetime, datetime]] = None,
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:
        &#34;&#34;&#34; Implement Haystack &#39;hisRead&#39; &#34;&#34;&#34;
        log.debug(
            &#34;----&gt; Call his_read(id=%s , range=%s, &#34; &#34;date_version=%s)&#34;,
            repr(entity_id),
            repr(dates_range),
            repr(date_version),
        )
        customer_id = self.get_customer_id()
        history = Grid(columns=[&#34;ts&#34;, &#34;val&#34;])
        if not date_version:
            date_version = datetime.max.replace(tzinfo=pytz.UTC)
        if dates_range[1] &gt; date_version:
            dates_range = list(dates_range)
            dates_range[1] = date_version

        ts_collection = self._get_ts_collection()

        cursor = ts_collection.find(
            {
                &#34;customer_id&#34;: customer_id,
                &#34;id&#34;: entity_id.name,
                &#34;ts&#34;:
                    {
                        &#34;$gte&#34;: dates_range[0],
                        &#34;$lt&#34;: dates_range[1]
                    }
            }).sort(&#34;ts&#34;)
        for row in cursor:
            history.append(
                {
                    &#34;ts&#34;: row[&#39;ts&#39;].replace(tzinfo=pytz.UTC),
                    &#34;val&#34;: json_parse_scalar(row[&#39;val&#39;])
                }
            )

        if history:
            min_date = datetime.max.replace(tzinfo=pytz.UTC)
            max_date = datetime.min.replace(tzinfo=pytz.UTC)

            for time_serie in history:
                min_date = min(min_date, time_serie[&#34;ts&#34;])
                max_date = max(max_date, time_serie[&#34;ts&#34;])
        else:
            min_date = date_version
            max_date = date_version

        history.metadata = {
            &#34;id&#34;: entity_id,
            &#34;hisStart&#34;: min_date,
            &#34;hisEnd&#34;: max_date,
        }
        return history

    def __exit__(self, exc_type, exc_value, exc_traceback):
        if self._client:
            self._client.close()
            self._connect = False

    # -----------------------------------------
    @overrides
    def create_db(self) -&gt; None:
        &#34;&#34;&#34;
        Create the database and schema.
        &#34;&#34;&#34;
        connect = self.get_db()
        if self._table_name not in connect.list_collection_names():
            collection = connect.create_collection(self._table_name)
            collection.create_index(
                [(&#34;customer_id&#34;, ASCENDING),
                 (&#34;start_datetime&#34;, ASCENDING),
                 (&#34;end_datetime&#34;, ASCENDING),
                 ])
        metadata_name = self._table_name + &#34;_meta_datas&#34;
        if metadata_name not in connect.list_collection_names():
            collection = connect.create_collection(metadata_name)
            collection.create_index(
                [
                    (&#34;customer_id&#34;, ASCENDING),
                    (&#34;start_datetime&#34;, ASCENDING),
                    (&#34;end_datetime&#34;, ASCENDING),
                ])
        ts_name = self._table_name + &#34;_ts&#34;
        if ts_name not in connect.list_collection_names():
            collection = connect.create_collection(ts_name)
            collection.create_index(
                [
                    (&#34;customer_id&#34;, ASCENDING),
                    (&#34;id&#34;, ASCENDING),
                    (&#34;ts&#34;, ASCENDING),
                ])

    @overrides
    def purge_db(self) -&gt; None:
        &#34;&#34;&#34; Purge the current database.
        All the datas was removed.
        &#34;&#34;&#34;
        connect = self.get_db()
        if self._table_name in connect.list_collection_names():
            connect[self._table_name].drop()
        metadata_name = self._table_name + &#34;_meta_datas&#34;
        if metadata_name in connect.list_collection_names():
            connect[metadata_name].drop()
        ts_name = self._table_name + &#34;_ts&#34;
        if ts_name in connect.list_collection_names():
            connect[ts_name].drop()

    @overrides
    def read_grid(self,
                  customer_id: str = &#39;&#39;,
                  version: Optional[datetime] = None) -&gt; Grid:
        &#34;&#34;&#34;
        Read all haystack data for a specific customer, from the database and return a Grid.
        Args:
            customer_id: The customer_id date to read
            version: version to load
        Returns:
            A grid with all data for a customer
        &#34;&#34;&#34;
        if version is None:
            version = datetime.now().replace(tzinfo=pytz.UTC)
        grid = self._init_grid_from_db(version)
        for row in self.get_collection().find(
                {
                    &#39;customer_id&#39;: customer_id,
                    &#39;start_datetime&#39;: {&#39;$lte&#39;: version},
                    &#39;end_datetime&#39;: {&#39;$gt&#39;: version},
                },
                {&#34;entity&#34;: True}):
            grid.append(_conv_row_to_entity(row[&#34;entity&#34;]))
        return grid

    def _read_partial_grid(self,
                           ids: List[Ref],
                           customer_id: str,
                           version: datetime) -&gt; Grid:
        &#34;&#34;&#34;
        Read all haystack data for a specific customer, from the database and return a Grid.
        Args:
            customer_id: The customer_id date to read
            version: version to load
        Returns:
            A grid with all data for a customer
        &#34;&#34;&#34;
        grid = self._init_grid_from_db(version)
        for row in self.get_collection().find(
                {
                    &#39;customer_id&#39;: customer_id,
                    &#39;start_datetime&#39;: {&#39;$lte&#39;: version},
                    &#39;end_datetime&#39;: {&#39;$gt&#39;: version},
                    &#39;entity.id&#39;: {
                        &#34;$in&#34;: [json_dump_scalar(id_entity)[1:-1] for id_entity in ids]
                    }
                },
                {&#34;entity&#34;: True}):
            grid.append(_conv_row_to_entity(row[&#34;entity&#34;]))
        return grid

    # noinspection PyPep8
    def _init_grid_from_db(self, version: Optional[datetime]) -&gt; Grid:
        customer_id = self.get_customer_id()
        if version is None:
            version = datetime.now().replace(tzinfo=pytz.UTC)
        meta_collection = self._get_meta_collection()

        grid = Grid(version=LATEST_VER)
        # noinspection PyPep8
        meta_record = list(meta_collection.aggregate(
            [
                # noinspection PyPep8
                {&#39;$match&#39;:
                    {
                        &#39;customer_id&#39;: customer_id,
                        &#39;start_datetime&#39;: {&#39;$lte&#39;: version},
                        &#39;end_datetime&#39;: {&#39;$gt&#39;: version},
                    }
                },
                {&#34;$project&#34;: {&#34;metadata&#34;: True, &#34;cols&#34;: True}}
            ]))
        if meta_record:
            grid.metadata = _parse_metadata(_conv_row_to_entity(meta_record[0][&#39;metadata&#39;]), LATEST_VER)
            _parse_cols(grid, meta_record[0][&#39;cols&#39;], LATEST_VER)
        return grid

    @overrides
    def update_grid(self,
                    diff_grid: Grid,
                    version: Optional[datetime],
                    customer_id: Optional[str],
                    now: Optional[datetime] = None) -&gt; None:
        &#34;&#34;&#34;Import the diff_grid inside the database.
        Args:
            diff_grid: The difference to apply in database.
            version: The version to save.
            customer_id: The customer id to insert in each row.
            now: The pseudo &#39;now&#39; datetime.
        &#34;&#34;&#34;
        if not customer_id:
            customer_id = &#34;&#34;
        if now is None:
            now = datetime.now(tz=pytz.UTC)
        if version is None:
            version = datetime.now().replace(tzinfo=pytz.UTC)
        end_date = now - timedelta(microseconds=1)

        # Read only modified rows
        init_grid = self._read_partial_grid(
            [row[&#39;id&#39;] for row in diff_grid],
            customer_id, version
        )
        # Updated rows
        new_grid = init_grid + diff_grid

        # Update metadata ?
        if new_grid.metadata != init_grid.metadata or new_grid.column != init_grid.column:
            haystack_meta_db = self._get_meta_collection()
            haystack_meta_db.update_one(
                {
                    &#34;customer_id&#34;: customer_id,
                    &#34;end_datetime&#34;: _END_OF_WORLD
                },
                {&#34;$set&#34;: {&#34;end_datetime&#34;: end_date}}
            )
            haystack_meta_db.insert_one(
                {
                    &#39;customer_id&#39;: customer_id,
                    &#34;start_datetime&#34;: version,
                    &#34;end_datetime&#34;: _END_OF_WORLD,
                    &#34;metadata&#34;: _dump_meta(new_grid.metadata),
                    &#34;cols&#34;: _dump_columns(new_grid.column)
                })
            log.debug(&#34;Update metadatas&#34;)
        # Close all entities
        haystack_db = self.get_collection()
        closed_id = [json_dump_scalar(row[&#34;id&#34;])[1:-1] for row in diff_grid]
        if closed_id:
            result = haystack_db.update_many(
                {
                    &#34;entity.id&#34;: {&#34;$in&#34;: closed_id},
                    &#34;end_datetime&#34;: _END_OF_WORLD
                },
                {&#34;$set&#34;: {&#34;end_datetime&#34;: end_date}}
            )
            log.debug(&#34;Close %s record(s)&#34;, result.modified_count)
            # Insert and update entities
            records = [
                {
                    &#34;customer_id&#34;: customer_id,
                    &#34;start_datetime&#34;: now,
                    &#34;end_datetime&#34;: _END_OF_WORLD,
                    &#34;entity&#34;: _conv_entity_to_row(new_grid[updated_entity[&#34;id&#34;]])
                }
                for updated_entity in diff_grid
                if updated_entity[&#34;id&#34;] in new_grid
            ]
            result = haystack_db.insert_many(records)
            log.debug(&#34;Import %s record(s)&#34;, len(result.inserted_ids))

    def import_data(self,  # pylint: disable=too-many-arguments
                    source_uri: str,
                    customer_id: str = &#39;&#39;,
                    reset: bool = False,
                    version: Optional[datetime] = None
                    ) -&gt; None:
        &#34;&#34;&#34;
        Import source URI to database.
        Args:
                source_uri: The source URI.
                customer_id: The customer id.
                reset: Remove all the current data before import the grid.
                version: The associated version time.
        &#34;&#34;&#34;
        if not version:
            version = datetime.now(tz=pytz.UTC)
        if not customer_id:
            customer_id = self.get_customer_id()
        if reset:
            self.purge_db()
        self.create_db()

        original_grid = self.read_grid(customer_id, version)
        target_grid = read_grid_from_uri(source_uri, envs=self._envs)
        self.update_grid(target_grid - original_grid, version, customer_id)

    # PPR: add transaction ?
    @overrides
    def import_ts(self,
                  source_uri: str,
                  customer_id: str = &#39;&#39;,
                  version: Optional[datetime] = None
                  ):
        target_grid = read_grid_from_uri(source_uri, envs=self._envs)
        dir_name = dirname(source_uri)
        for row in target_grid:
            if &#34;hisURI&#34; in row:
                assert &#34;id&#34; in row, &#34;TS must have an id&#34;
                uri = dir_name + &#39;/&#39; + row[&#39;hisURI&#39;]
                ts_grid = read_grid_from_uri(uri, envs=self._envs)
                self._import_ts_in_db(ts_grid, row[&#34;id&#34;], customer_id)
                log.debug(&#34;%s imported&#34;, uri)
            elif &#34;history&#34; in row:
                ts_grid = row[&#34;history&#34;]
                self._import_ts_in_db(ts_grid, row[&#34;id&#34;], customer_id)
                log.debug(&#34;%s imported&#34;, uri)

    # noinspection PyUnusedLocal
    def _import_ts_in_db(self,
                         time_series: Grid,
                         entity_id: Ref,
                         customer_id: Optional[str],
                         now: Optional[datetime] = None
                         ) -&gt; None:
        assert &#39;ts&#39; in time_series.column, &#34;TS must have a column &#39;ts&#39;&#34;
        if not customer_id:
            customer_id = &#34;&#34;
        ts_collection = self._get_ts_collection()
        begin_datetime = time_series.metadata.get(&#34;hisStart&#34;)
        end_datetime = time_series.metadata.get(&#34;hisStart&#34;)
        if time_series and not begin_datetime:
            begin_datetime = time_series[0][&#39;ts&#39;]
        if time_series and not end_datetime:
            end_datetime = time_series[-1][&#39;ts&#39;]
        if not begin_datetime:
            begin_datetime = datetime.min
        if not end_datetime:
            end_datetime = datetime.max

        #                 id TEXT NOT NULL,
        #                 customer_id TEXT NOT NULL,
        #                 date_time TIMESTAMP WITH TIME ZONE NOT NULL,
        #                 val JSONB NOT NULL
        # Clean only the period
        ts_collection.delete_many(
            {
                &#34;customer_id&#34;: customer_id,
                &#34;id&#34;: entity_id.name,
                &#34;ts&#34;:
                    {
                        &#34;$gte&#34;: begin_datetime,
                        &#34;$lt&#34;: end_datetime
                    }
            })

        # Add add new values
        ts_collection.insert_many(
            [
                {
                    &#34;customer_id&#34;: customer_id,
                    &#34;id&#34;: entity_id.name,
                    &#34;ts&#34;: row[&#39;ts&#39;],
                    &#34;val&#34;: json_dump_scalar(row[&#39;val&#39;])
                }
                for row in time_series
            ]
        )

    def get_db(self) -&gt; Database:
        if not self._connect:  # Lazy connection
            database_name = self._parsed_db.path
            if database_name:
                database_name = database_name[1:]
            self._parsed_db.geturl()
            self._client = self._connect = MongoClient(
                self._get_db(),
            )
            connect = self._client[database_name]
            self._connect = connect
            self.create_db()
        return self._connect

    def get_collection(self) -&gt; Collection:
        mongodb = self.get_db()
        return mongodb[self._table_name]

    def _get_meta_collection(self) -&gt; Collection:
        mongodb = self.get_db()
        return mongodb[self._table_name + &#34;_meta_datas&#34;]

    def _get_ts_collection(self) -&gt; Collection:
        mongodb = self.get_db()
        return mongodb[self._table_name + &#34;_ts&#34;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shaystack.providers.mongodb.Provider"><code class="flex name class">
<span>class <span class="ident">Provider</span></span>
<span>(</span><span>envs:Â Dict[str,Â str])</span>
</code></dt>
<dd>
<div class="desc"><p>Expose an Haystack data via the Haystack Rest API and SQL databases</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Provider(DBHaystackInterface):
    &#34;&#34;&#34;
    Expose an Haystack data via the Haystack Rest API and SQL databases
    &#34;&#34;&#34;
    __slots__ = &#39;_connect&#39;, &#39;_client&#39;, &#39;_parsed_db&#39;, &#39;_table_name&#39;, &#39;_envs&#39;, &#39;_db_url&#39;

    def __init__(self, envs: Dict[str, str]):
        DBHaystackInterface.__init__(self, envs)
        self._connect = None
        self._client = None
        self._table_name = None
        self._db_url = self._envs[&#34;HAYSTACK_DB&#34;]
        log.info(&#34;Use %s&#34;, self._get_db())
        self._parsed_db = urlparse(self._get_db())

        table_name = self._parsed_db.fragment
        if not table_name:
            table_name = &#34;haystack&#34;
        else:
            parts = list(self._parsed_db)
            self._db_url = urlunparse(parts[:-1] + [&#39;&#39;])  # Remove fragment
            self._parsed_db = urlparse(self._db_url)
        self._table_name = table_name

        password = self._parsed_db.password
        if _BOTO3_AVAILABLE and self._parsed_db.username and \
                password.startswith(&#34;&lt;&#34;) and password.endswith(&#34;&gt;&#34;):
            password = get_secret_manager_secret(password[1:-1], self._envs)
            parts = list(self._parsed_db)
            user, _, host = re.split(&#39;[:|@]&#39;, parts[1])
            parts[1] = f&#34;{user}:{password}@{host}&#34;
            self._db_url = urlunparse(parts)
            self._parsed_db = urlparse(urlunparse(parts))

    def _get_db(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Return the url to the file to expose. &#34;&#34;&#34;
        return self._db_url

    @property
    def name(self) -&gt; str:
        return &#34;MongoDB&#34;

    @overrides
    def values_for_tag(self, tag: str,
                       date_version: Optional[datetime] = None) -&gt; List[Any]:
        return sorted([
            json_parse_scalar(val)
            for val in self.get_collection().distinct(
                f&#34;entity.{tag}&#34;,
                {
                    &#34;customer_id&#34;: self.get_customer_id()
                }
            )])

    @overrides
    def versions(self) -&gt; List[datetime]:
        &#34;&#34;&#34;
        Return datetime for each versions or empty array if is unknown
        &#34;&#34;&#34;
        return sorted(self.get_collection().distinct(
            &#34;start_datetime&#34;,
            {
                &#34;customer_id&#34;: self.get_customer_id()
            }
        ))

    @overrides
    def about(self, home: str) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;about&#39; operation &#34;&#34;&#34;
        grid = super().about(home)
        about_data = cast(Entity, grid[0])
        about_data.update(
            {  # pylint: disable=no-member
                &#34;productVersion&#34;: &#34;1.0&#34;,
                &#34;moduleName&#34;: &#34;MongoProvider&#34;,
                &#34;moduleVersion&#34;: &#34;1.0&#34;,
            }
        )
        return grid

    @overrides
    def read(
            self,
            limit: int,
            select: Optional[str],
            entity_ids: Optional[List[Ref]] = None,
            grid_filter: Optional[str] = None,
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:
        &#34;&#34;&#34; Implement Haystack &#39;read&#39; &#34;&#34;&#34;
        log.debug(
            &#34;----&gt; Call read(limit=%s, select=&#39;%s&#39;, ids=%s grid_filter=&#39;%s&#39; date_version=%s)&#34;,
            repr(limit),
            repr(select),
            repr(entity_ids),
            repr(grid_filter),
            repr(date_version),
        )
        if date_version is None:
            date_version = datetime.now().replace(tzinfo=pytz.UTC)

        if entity_ids is None:
            cursor = self.get_collection().aggregate(
                mongo_filter(grid_filter, date_version, limit, self.get_customer_id())
            )

            grid = self._init_grid_from_db(date_version)
            for row in cursor:
                grid.append(_conv_row_to_entity(row))
            return grid.select(select)

        customer_id = self.get_customer_id()
        cursor = self.get_collection().aggregate(
            [
                {&#39;$match&#39;: {&#39;customer_id&#39;: customer_id,
                            &#39;start_datetime&#39;: {&#39;$lte&#39;: date_version},
                            &#39;end_datetime&#39;: {&#39;$gt&#39;: date_version}}},
                {&#39;$replaceRoot&#39;: {&#39;newRoot&#39;: &#39;$entity&#39;}},
                {
                    &#39;$match&#39;: {
                        &#39;$expr&#39;: {
                            &#39;$in&#39;: [
                                {
                                    &#39;$let&#39;: {
                                        &#39;vars&#39;: {&#39;id_regex_&#39;:
                                            {
                                                &#39;$regexFind&#39;: {
                                                    &#39;input&#39;: &#39;$id&#39;,
                                                    &#39;regex&#39;: &#39;r:([:.~a-zA-Z0-9_-]+)&#39;
                                                }
                                            }
                                        },
                                        &#39;in&#39;: {&#39;$arrayElemAt&#39;: [&#39;$$id_regex_.captures&#39;, 0]}
                                    }
                                },
                                [ref.name for ref in entity_ids]
                            ]
                        }
                    }
                },
            ]
        )

        grid = self._init_grid_from_db(date_version)
        for row in cursor:
            grid.append(_conv_row_to_entity(row))
        return grid.select(select)

    @overrides
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Optional[Tuple[datetime, datetime]] = None,
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:
        &#34;&#34;&#34; Implement Haystack &#39;hisRead&#39; &#34;&#34;&#34;
        log.debug(
            &#34;----&gt; Call his_read(id=%s , range=%s, &#34; &#34;date_version=%s)&#34;,
            repr(entity_id),
            repr(dates_range),
            repr(date_version),
        )
        customer_id = self.get_customer_id()
        history = Grid(columns=[&#34;ts&#34;, &#34;val&#34;])
        if not date_version:
            date_version = datetime.max.replace(tzinfo=pytz.UTC)
        if dates_range[1] &gt; date_version:
            dates_range = list(dates_range)
            dates_range[1] = date_version

        ts_collection = self._get_ts_collection()

        cursor = ts_collection.find(
            {
                &#34;customer_id&#34;: customer_id,
                &#34;id&#34;: entity_id.name,
                &#34;ts&#34;:
                    {
                        &#34;$gte&#34;: dates_range[0],
                        &#34;$lt&#34;: dates_range[1]
                    }
            }).sort(&#34;ts&#34;)
        for row in cursor:
            history.append(
                {
                    &#34;ts&#34;: row[&#39;ts&#39;].replace(tzinfo=pytz.UTC),
                    &#34;val&#34;: json_parse_scalar(row[&#39;val&#39;])
                }
            )

        if history:
            min_date = datetime.max.replace(tzinfo=pytz.UTC)
            max_date = datetime.min.replace(tzinfo=pytz.UTC)

            for time_serie in history:
                min_date = min(min_date, time_serie[&#34;ts&#34;])
                max_date = max(max_date, time_serie[&#34;ts&#34;])
        else:
            min_date = date_version
            max_date = date_version

        history.metadata = {
            &#34;id&#34;: entity_id,
            &#34;hisStart&#34;: min_date,
            &#34;hisEnd&#34;: max_date,
        }
        return history

    def __exit__(self, exc_type, exc_value, exc_traceback):
        if self._client:
            self._client.close()
            self._connect = False

    # -----------------------------------------
    @overrides
    def create_db(self) -&gt; None:
        &#34;&#34;&#34;
        Create the database and schema.
        &#34;&#34;&#34;
        connect = self.get_db()
        if self._table_name not in connect.list_collection_names():
            collection = connect.create_collection(self._table_name)
            collection.create_index(
                [(&#34;customer_id&#34;, ASCENDING),
                 (&#34;start_datetime&#34;, ASCENDING),
                 (&#34;end_datetime&#34;, ASCENDING),
                 ])
        metadata_name = self._table_name + &#34;_meta_datas&#34;
        if metadata_name not in connect.list_collection_names():
            collection = connect.create_collection(metadata_name)
            collection.create_index(
                [
                    (&#34;customer_id&#34;, ASCENDING),
                    (&#34;start_datetime&#34;, ASCENDING),
                    (&#34;end_datetime&#34;, ASCENDING),
                ])
        ts_name = self._table_name + &#34;_ts&#34;
        if ts_name not in connect.list_collection_names():
            collection = connect.create_collection(ts_name)
            collection.create_index(
                [
                    (&#34;customer_id&#34;, ASCENDING),
                    (&#34;id&#34;, ASCENDING),
                    (&#34;ts&#34;, ASCENDING),
                ])

    @overrides
    def purge_db(self) -&gt; None:
        &#34;&#34;&#34; Purge the current database.
        All the datas was removed.
        &#34;&#34;&#34;
        connect = self.get_db()
        if self._table_name in connect.list_collection_names():
            connect[self._table_name].drop()
        metadata_name = self._table_name + &#34;_meta_datas&#34;
        if metadata_name in connect.list_collection_names():
            connect[metadata_name].drop()
        ts_name = self._table_name + &#34;_ts&#34;
        if ts_name in connect.list_collection_names():
            connect[ts_name].drop()

    @overrides
    def read_grid(self,
                  customer_id: str = &#39;&#39;,
                  version: Optional[datetime] = None) -&gt; Grid:
        &#34;&#34;&#34;
        Read all haystack data for a specific customer, from the database and return a Grid.
        Args:
            customer_id: The customer_id date to read
            version: version to load
        Returns:
            A grid with all data for a customer
        &#34;&#34;&#34;
        if version is None:
            version = datetime.now().replace(tzinfo=pytz.UTC)
        grid = self._init_grid_from_db(version)
        for row in self.get_collection().find(
                {
                    &#39;customer_id&#39;: customer_id,
                    &#39;start_datetime&#39;: {&#39;$lte&#39;: version},
                    &#39;end_datetime&#39;: {&#39;$gt&#39;: version},
                },
                {&#34;entity&#34;: True}):
            grid.append(_conv_row_to_entity(row[&#34;entity&#34;]))
        return grid

    def _read_partial_grid(self,
                           ids: List[Ref],
                           customer_id: str,
                           version: datetime) -&gt; Grid:
        &#34;&#34;&#34;
        Read all haystack data for a specific customer, from the database and return a Grid.
        Args:
            customer_id: The customer_id date to read
            version: version to load
        Returns:
            A grid with all data for a customer
        &#34;&#34;&#34;
        grid = self._init_grid_from_db(version)
        for row in self.get_collection().find(
                {
                    &#39;customer_id&#39;: customer_id,
                    &#39;start_datetime&#39;: {&#39;$lte&#39;: version},
                    &#39;end_datetime&#39;: {&#39;$gt&#39;: version},
                    &#39;entity.id&#39;: {
                        &#34;$in&#34;: [json_dump_scalar(id_entity)[1:-1] for id_entity in ids]
                    }
                },
                {&#34;entity&#34;: True}):
            grid.append(_conv_row_to_entity(row[&#34;entity&#34;]))
        return grid

    # noinspection PyPep8
    def _init_grid_from_db(self, version: Optional[datetime]) -&gt; Grid:
        customer_id = self.get_customer_id()
        if version is None:
            version = datetime.now().replace(tzinfo=pytz.UTC)
        meta_collection = self._get_meta_collection()

        grid = Grid(version=LATEST_VER)
        # noinspection PyPep8
        meta_record = list(meta_collection.aggregate(
            [
                # noinspection PyPep8
                {&#39;$match&#39;:
                    {
                        &#39;customer_id&#39;: customer_id,
                        &#39;start_datetime&#39;: {&#39;$lte&#39;: version},
                        &#39;end_datetime&#39;: {&#39;$gt&#39;: version},
                    }
                },
                {&#34;$project&#34;: {&#34;metadata&#34;: True, &#34;cols&#34;: True}}
            ]))
        if meta_record:
            grid.metadata = _parse_metadata(_conv_row_to_entity(meta_record[0][&#39;metadata&#39;]), LATEST_VER)
            _parse_cols(grid, meta_record[0][&#39;cols&#39;], LATEST_VER)
        return grid

    @overrides
    def update_grid(self,
                    diff_grid: Grid,
                    version: Optional[datetime],
                    customer_id: Optional[str],
                    now: Optional[datetime] = None) -&gt; None:
        &#34;&#34;&#34;Import the diff_grid inside the database.
        Args:
            diff_grid: The difference to apply in database.
            version: The version to save.
            customer_id: The customer id to insert in each row.
            now: The pseudo &#39;now&#39; datetime.
        &#34;&#34;&#34;
        if not customer_id:
            customer_id = &#34;&#34;
        if now is None:
            now = datetime.now(tz=pytz.UTC)
        if version is None:
            version = datetime.now().replace(tzinfo=pytz.UTC)
        end_date = now - timedelta(microseconds=1)

        # Read only modified rows
        init_grid = self._read_partial_grid(
            [row[&#39;id&#39;] for row in diff_grid],
            customer_id, version
        )
        # Updated rows
        new_grid = init_grid + diff_grid

        # Update metadata ?
        if new_grid.metadata != init_grid.metadata or new_grid.column != init_grid.column:
            haystack_meta_db = self._get_meta_collection()
            haystack_meta_db.update_one(
                {
                    &#34;customer_id&#34;: customer_id,
                    &#34;end_datetime&#34;: _END_OF_WORLD
                },
                {&#34;$set&#34;: {&#34;end_datetime&#34;: end_date}}
            )
            haystack_meta_db.insert_one(
                {
                    &#39;customer_id&#39;: customer_id,
                    &#34;start_datetime&#34;: version,
                    &#34;end_datetime&#34;: _END_OF_WORLD,
                    &#34;metadata&#34;: _dump_meta(new_grid.metadata),
                    &#34;cols&#34;: _dump_columns(new_grid.column)
                })
            log.debug(&#34;Update metadatas&#34;)
        # Close all entities
        haystack_db = self.get_collection()
        closed_id = [json_dump_scalar(row[&#34;id&#34;])[1:-1] for row in diff_grid]
        if closed_id:
            result = haystack_db.update_many(
                {
                    &#34;entity.id&#34;: {&#34;$in&#34;: closed_id},
                    &#34;end_datetime&#34;: _END_OF_WORLD
                },
                {&#34;$set&#34;: {&#34;end_datetime&#34;: end_date}}
            )
            log.debug(&#34;Close %s record(s)&#34;, result.modified_count)
            # Insert and update entities
            records = [
                {
                    &#34;customer_id&#34;: customer_id,
                    &#34;start_datetime&#34;: now,
                    &#34;end_datetime&#34;: _END_OF_WORLD,
                    &#34;entity&#34;: _conv_entity_to_row(new_grid[updated_entity[&#34;id&#34;]])
                }
                for updated_entity in diff_grid
                if updated_entity[&#34;id&#34;] in new_grid
            ]
            result = haystack_db.insert_many(records)
            log.debug(&#34;Import %s record(s)&#34;, len(result.inserted_ids))

    def import_data(self,  # pylint: disable=too-many-arguments
                    source_uri: str,
                    customer_id: str = &#39;&#39;,
                    reset: bool = False,
                    version: Optional[datetime] = None
                    ) -&gt; None:
        &#34;&#34;&#34;
        Import source URI to database.
        Args:
                source_uri: The source URI.
                customer_id: The customer id.
                reset: Remove all the current data before import the grid.
                version: The associated version time.
        &#34;&#34;&#34;
        if not version:
            version = datetime.now(tz=pytz.UTC)
        if not customer_id:
            customer_id = self.get_customer_id()
        if reset:
            self.purge_db()
        self.create_db()

        original_grid = self.read_grid(customer_id, version)
        target_grid = read_grid_from_uri(source_uri, envs=self._envs)
        self.update_grid(target_grid - original_grid, version, customer_id)

    # PPR: add transaction ?
    @overrides
    def import_ts(self,
                  source_uri: str,
                  customer_id: str = &#39;&#39;,
                  version: Optional[datetime] = None
                  ):
        target_grid = read_grid_from_uri(source_uri, envs=self._envs)
        dir_name = dirname(source_uri)
        for row in target_grid:
            if &#34;hisURI&#34; in row:
                assert &#34;id&#34; in row, &#34;TS must have an id&#34;
                uri = dir_name + &#39;/&#39; + row[&#39;hisURI&#39;]
                ts_grid = read_grid_from_uri(uri, envs=self._envs)
                self._import_ts_in_db(ts_grid, row[&#34;id&#34;], customer_id)
                log.debug(&#34;%s imported&#34;, uri)
            elif &#34;history&#34; in row:
                ts_grid = row[&#34;history&#34;]
                self._import_ts_in_db(ts_grid, row[&#34;id&#34;], customer_id)
                log.debug(&#34;%s imported&#34;, uri)

    # noinspection PyUnusedLocal
    def _import_ts_in_db(self,
                         time_series: Grid,
                         entity_id: Ref,
                         customer_id: Optional[str],
                         now: Optional[datetime] = None
                         ) -&gt; None:
        assert &#39;ts&#39; in time_series.column, &#34;TS must have a column &#39;ts&#39;&#34;
        if not customer_id:
            customer_id = &#34;&#34;
        ts_collection = self._get_ts_collection()
        begin_datetime = time_series.metadata.get(&#34;hisStart&#34;)
        end_datetime = time_series.metadata.get(&#34;hisStart&#34;)
        if time_series and not begin_datetime:
            begin_datetime = time_series[0][&#39;ts&#39;]
        if time_series and not end_datetime:
            end_datetime = time_series[-1][&#39;ts&#39;]
        if not begin_datetime:
            begin_datetime = datetime.min
        if not end_datetime:
            end_datetime = datetime.max

        #                 id TEXT NOT NULL,
        #                 customer_id TEXT NOT NULL,
        #                 date_time TIMESTAMP WITH TIME ZONE NOT NULL,
        #                 val JSONB NOT NULL
        # Clean only the period
        ts_collection.delete_many(
            {
                &#34;customer_id&#34;: customer_id,
                &#34;id&#34;: entity_id.name,
                &#34;ts&#34;:
                    {
                        &#34;$gte&#34;: begin_datetime,
                        &#34;$lt&#34;: end_datetime
                    }
            })

        # Add add new values
        ts_collection.insert_many(
            [
                {
                    &#34;customer_id&#34;: customer_id,
                    &#34;id&#34;: entity_id.name,
                    &#34;ts&#34;: row[&#39;ts&#39;],
                    &#34;val&#34;: json_dump_scalar(row[&#39;val&#39;])
                }
                for row in time_series
            ]
        )

    def get_db(self) -&gt; Database:
        if not self._connect:  # Lazy connection
            database_name = self._parsed_db.path
            if database_name:
                database_name = database_name[1:]
            self._parsed_db.geturl()
            self._client = self._connect = MongoClient(
                self._get_db(),
            )
            connect = self._client[database_name]
            self._connect = connect
            self.create_db()
        return self._connect

    def get_collection(self) -&gt; Collection:
        mongodb = self.get_db()
        return mongodb[self._table_name]

    def _get_meta_collection(self) -&gt; Collection:
        mongodb = self.get_db()
        return mongodb[self._table_name + &#34;_meta_datas&#34;]

    def _get_ts_collection(self) -&gt; Collection:
        mongodb = self.get_db()
        return mongodb[self._table_name + &#34;_ts&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface">DBHaystackInterface</a></li>
<li><a title="shaystack.providers.haystack_interface.HaystackInterface" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="shaystack.providers.mongodb.Provider.about"><code class="name flex">
<span>def <span class="ident">about</span></span>(<span>self, home:Â str) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'about' operation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@overrides
def about(self, home: str) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;about&#39; operation &#34;&#34;&#34;
    grid = super().about(home)
    about_data = cast(Entity, grid[0])
    about_data.update(
        {  # pylint: disable=no-member
            &#34;productVersion&#34;: &#34;1.0&#34;,
            &#34;moduleName&#34;: &#34;MongoProvider&#34;,
            &#34;moduleVersion&#34;: &#34;1.0&#34;,
        }
    )
    return grid</code></pre>
</details>
</dd>
<dt id="shaystack.providers.mongodb.Provider.get_collection"><code class="name flex">
<span>def <span class="ident">get_collection</span></span>(<span>self) â€‘>Â pymongo.collection.Collection</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_collection(self) -&gt; Collection:
    mongodb = self.get_db()
    return mongodb[self._table_name]</code></pre>
</details>
</dd>
<dt id="shaystack.providers.mongodb.Provider.get_db"><code class="name flex">
<span>def <span class="ident">get_db</span></span>(<span>self) â€‘>Â pymongo.database.Database</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_db(self) -&gt; Database:
    if not self._connect:  # Lazy connection
        database_name = self._parsed_db.path
        if database_name:
            database_name = database_name[1:]
        self._parsed_db.geturl()
        self._client = self._connect = MongoClient(
            self._get_db(),
        )
        connect = self._client[database_name]
        self._connect = connect
        self.create_db()
    return self._connect</code></pre>
</details>
</dd>
<dt id="shaystack.providers.mongodb.Provider.his_read"><code class="name flex">
<span>def <span class="ident">his_read</span></span>(<span>self, entity_id:Â shaystack.datatypes.Ref, dates_range:Â Union[Tuple[datetime.datetime,Â datetime.datetime],Â NoneType]Â =Â None, date_version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'hisRead'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@overrides
def his_read(
        self,
        entity_id: Ref,
        dates_range: Optional[Tuple[datetime, datetime]] = None,
        date_version: Optional[datetime] = None,
) -&gt; Grid:
    &#34;&#34;&#34; Implement Haystack &#39;hisRead&#39; &#34;&#34;&#34;
    log.debug(
        &#34;----&gt; Call his_read(id=%s , range=%s, &#34; &#34;date_version=%s)&#34;,
        repr(entity_id),
        repr(dates_range),
        repr(date_version),
    )
    customer_id = self.get_customer_id()
    history = Grid(columns=[&#34;ts&#34;, &#34;val&#34;])
    if not date_version:
        date_version = datetime.max.replace(tzinfo=pytz.UTC)
    if dates_range[1] &gt; date_version:
        dates_range = list(dates_range)
        dates_range[1] = date_version

    ts_collection = self._get_ts_collection()

    cursor = ts_collection.find(
        {
            &#34;customer_id&#34;: customer_id,
            &#34;id&#34;: entity_id.name,
            &#34;ts&#34;:
                {
                    &#34;$gte&#34;: dates_range[0],
                    &#34;$lt&#34;: dates_range[1]
                }
        }).sort(&#34;ts&#34;)
    for row in cursor:
        history.append(
            {
                &#34;ts&#34;: row[&#39;ts&#39;].replace(tzinfo=pytz.UTC),
                &#34;val&#34;: json_parse_scalar(row[&#39;val&#39;])
            }
        )

    if history:
        min_date = datetime.max.replace(tzinfo=pytz.UTC)
        max_date = datetime.min.replace(tzinfo=pytz.UTC)

        for time_serie in history:
            min_date = min(min_date, time_serie[&#34;ts&#34;])
            max_date = max(max_date, time_serie[&#34;ts&#34;])
    else:
        min_date = date_version
        max_date = date_version

    history.metadata = {
        &#34;id&#34;: entity_id,
        &#34;hisStart&#34;: min_date,
        &#34;hisEnd&#34;: max_date,
    }
    return history</code></pre>
</details>
</dd>
<dt id="shaystack.providers.mongodb.Provider.import_data"><code class="name flex">
<span>def <span class="ident">import_data</span></span>(<span>self, source_uri:Â str, customer_id:Â strÂ =Â '', reset:Â boolÂ =Â False, version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Import source URI to database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_uri</code></strong></dt>
<dd>The source URI.</dd>
<dt><strong><code>customer_id</code></strong></dt>
<dd>The customer id.</dd>
<dt><strong><code>reset</code></strong></dt>
<dd>Remove all the current data before import the grid.</dd>
<dt><strong><code>version</code></strong></dt>
<dd>The associated version time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_data(self,  # pylint: disable=too-many-arguments
                source_uri: str,
                customer_id: str = &#39;&#39;,
                reset: bool = False,
                version: Optional[datetime] = None
                ) -&gt; None:
    &#34;&#34;&#34;
    Import source URI to database.
    Args:
            source_uri: The source URI.
            customer_id: The customer id.
            reset: Remove all the current data before import the grid.
            version: The associated version time.
    &#34;&#34;&#34;
    if not version:
        version = datetime.now(tz=pytz.UTC)
    if not customer_id:
        customer_id = self.get_customer_id()
    if reset:
        self.purge_db()
    self.create_db()

    original_grid = self.read_grid(customer_id, version)
    target_grid = read_grid_from_uri(source_uri, envs=self._envs)
    self.update_grid(target_grid - original_grid, version, customer_id)</code></pre>
</details>
</dd>
<dt id="shaystack.providers.mongodb.Provider.purge_db"><code class="name flex">
<span>def <span class="ident">purge_db</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Purge the current database.
All the datas was removed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@overrides
def purge_db(self) -&gt; None:
    &#34;&#34;&#34; Purge the current database.
    All the datas was removed.
    &#34;&#34;&#34;
    connect = self.get_db()
    if self._table_name in connect.list_collection_names():
        connect[self._table_name].drop()
    metadata_name = self._table_name + &#34;_meta_datas&#34;
    if metadata_name in connect.list_collection_names():
        connect[metadata_name].drop()
    ts_name = self._table_name + &#34;_ts&#34;
    if ts_name in connect.list_collection_names():
        connect[ts_name].drop()</code></pre>
</details>
</dd>
<dt id="shaystack.providers.mongodb.Provider.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, limit:Â int, select:Â Union[str,Â NoneType], entity_ids:Â Union[List[shaystack.datatypes.Ref],Â NoneType]Â =Â None, grid_filter:Â Union[str,Â NoneType]Â =Â None, date_version:Â Union[datetime.datetime,Â NoneType]Â =Â None) â€‘>Â shaystack.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement Haystack 'read'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@overrides
def read(
        self,
        limit: int,
        select: Optional[str],
        entity_ids: Optional[List[Ref]] = None,
        grid_filter: Optional[str] = None,
        date_version: Optional[datetime] = None,
) -&gt; Grid:
    &#34;&#34;&#34; Implement Haystack &#39;read&#39; &#34;&#34;&#34;
    log.debug(
        &#34;----&gt; Call read(limit=%s, select=&#39;%s&#39;, ids=%s grid_filter=&#39;%s&#39; date_version=%s)&#34;,
        repr(limit),
        repr(select),
        repr(entity_ids),
        repr(grid_filter),
        repr(date_version),
    )
    if date_version is None:
        date_version = datetime.now().replace(tzinfo=pytz.UTC)

    if entity_ids is None:
        cursor = self.get_collection().aggregate(
            mongo_filter(grid_filter, date_version, limit, self.get_customer_id())
        )

        grid = self._init_grid_from_db(date_version)
        for row in cursor:
            grid.append(_conv_row_to_entity(row))
        return grid.select(select)

    customer_id = self.get_customer_id()
    cursor = self.get_collection().aggregate(
        [
            {&#39;$match&#39;: {&#39;customer_id&#39;: customer_id,
                        &#39;start_datetime&#39;: {&#39;$lte&#39;: date_version},
                        &#39;end_datetime&#39;: {&#39;$gt&#39;: date_version}}},
            {&#39;$replaceRoot&#39;: {&#39;newRoot&#39;: &#39;$entity&#39;}},
            {
                &#39;$match&#39;: {
                    &#39;$expr&#39;: {
                        &#39;$in&#39;: [
                            {
                                &#39;$let&#39;: {
                                    &#39;vars&#39;: {&#39;id_regex_&#39;:
                                        {
                                            &#39;$regexFind&#39;: {
                                                &#39;input&#39;: &#39;$id&#39;,
                                                &#39;regex&#39;: &#39;r:([:.~a-zA-Z0-9_-]+)&#39;
                                            }
                                        }
                                    },
                                    &#39;in&#39;: {&#39;$arrayElemAt&#39;: [&#39;$$id_regex_.captures&#39;, 0]}
                                }
                            },
                            [ref.name for ref in entity_ids]
                        ]
                    }
                }
            },
        ]
    )

    grid = self._init_grid_from_db(date_version)
    for row in cursor:
        grid.append(_conv_row_to_entity(row))
    return grid.select(select)</code></pre>
</details>
</dd>
<dt id="shaystack.providers.mongodb.Provider.versions"><code class="name flex">
<span>def <span class="ident">versions</span></span>(<span>self) â€‘>Â List[datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"><p>Return datetime for each versions or empty array if is unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@overrides
def versions(self) -&gt; List[datetime]:
    &#34;&#34;&#34;
    Return datetime for each versions or empty array if is unknown
    &#34;&#34;&#34;
    return sorted(self.get_collection().distinct(
        &#34;start_datetime&#34;,
        {
            &#34;customer_id&#34;: self.get_customer_id()
        }
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface">DBHaystackInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.create_db" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.create_db">create_db</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.formats" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.formats">formats</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.get_customer_id" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.get_customer_id">get_customer_id</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.get_tz" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.get_tz">get_tz</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.his_write" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.his_write">his_write</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.import_ts" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.import_ts">import_ts</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.invoke_action" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.invoke_action">invoke_action</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.name" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.name">name</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.nav" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.nav">nav</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.ops" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.ops">ops</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.point_write_read" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.point_write_read">point_write_read</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.point_write_write" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.point_write_write">point_write_write</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.read_grid" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.read_grid">read_grid</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.update_grid" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.update_grid">update_grid</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.values_for_tag" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.values_for_tag">values_for_tag</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.watch_poll" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.watch_poll">watch_poll</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.watch_sub" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.watch_sub">watch_sub</a></code></li>
<li><code><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface.watch_unsub" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.watch_unsub">watch_unsub</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shaystack.providers" href="index.html">shaystack.providers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shaystack.providers.mongodb.Provider" href="#shaystack.providers.mongodb.Provider">Provider</a></code></h4>
<ul class="two-column">
<li><code><a title="shaystack.providers.mongodb.Provider.about" href="#shaystack.providers.mongodb.Provider.about">about</a></code></li>
<li><code><a title="shaystack.providers.mongodb.Provider.get_collection" href="#shaystack.providers.mongodb.Provider.get_collection">get_collection</a></code></li>
<li><code><a title="shaystack.providers.mongodb.Provider.get_db" href="#shaystack.providers.mongodb.Provider.get_db">get_db</a></code></li>
<li><code><a title="shaystack.providers.mongodb.Provider.his_read" href="#shaystack.providers.mongodb.Provider.his_read">his_read</a></code></li>
<li><code><a title="shaystack.providers.mongodb.Provider.import_data" href="#shaystack.providers.mongodb.Provider.import_data">import_data</a></code></li>
<li><code><a title="shaystack.providers.mongodb.Provider.purge_db" href="#shaystack.providers.mongodb.Provider.purge_db">purge_db</a></code></li>
<li><code><a title="shaystack.providers.mongodb.Provider.read" href="#shaystack.providers.mongodb.Provider.read">read</a></code></li>
<li><code><a title="shaystack.providers.mongodb.Provider.versions" href="#shaystack.providers.mongodb.Provider.versions">versions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>