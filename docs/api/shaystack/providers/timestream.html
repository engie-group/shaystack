<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shaystack.providers.timestream API documentation</title>
<meta name="description" content="Add the persistance of time-series with TS database …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shaystack.providers.timestream</code></h1>
</header>
<section id="section-intro">
<p>Add the persistance of time-series with TS database.</p>
<p>Set the HAYSTACK_TS with Time-series database connection URL,
(timestream://HaystackDemo/?mem_ttl=1&amp;mag_ttl=100#haystack)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# SQL + TS provider
# See the accompanying LICENSE file.
# (C) 2021 Engie Digital
#
# vim: set ts=4 sts=4 et tw=78 sw=4 si:
&#34;&#34;&#34;
Add the persistance of time-series with TS database.

Set the HAYSTACK_TS with Time-series database connection URL,
(timestream://HaystackDemo/?mem_ttl=1&amp;mag_ttl=100#haystack)
&#34;&#34;&#34;
from datetime import datetime, date, time
from os.path import dirname
from typing import Optional, Tuple, Callable, Any, Dict
from urllib.parse import parse_qs
from urllib.parse import urlparse

import boto3
import dateutil
import pytz
from botocore.client import BaseClient
from botocore.config import Config
from overrides import overrides

from .db import Provider as DBProvider
from .db import log
from .url import read_grid_from_uri
from ..datatypes import Ref, MARKER, REMOVE, Coordinate, Quantity, NA, XStr
from ..grid import Grid

_MAX_ROWS_BY_WRITE = 100
_DEFAULT_MEM_TTL = 8766
_DEFAULT_MAG_TTL = 400


def _create_database(client: BaseClient,
                     database: str) -&gt; None:
    try:
        client.create_database(DatabaseName=database)
        log.info(&#34;Database [%s] created successfully.&#34;, database)
    except client.exceptions.ConflictException:
        # Database exists. Skipping database creation
        log.debug(&#34;Database [%s] exists. Skipping database creation.&#34;, database)


def _create_table(client: BaseClient,
                  database: str,
                  table_name: str,
                  mem_ttl: int,
                  mag_ttl: int) -&gt; None:
    try:
        client.create_table(DatabaseName=database,
                            TableName=table_name,
                            RetentionProperties={
                                &#39;MemoryStoreRetentionPeriodInHours&#39;: mem_ttl,
                                &#39;MagneticStoreRetentionPeriodInDays&#39;: mag_ttl
                            })
        log.info(&#34;Table [%s] successfully created (memory ttl: %sh, magnetic ttl: %sd.&#34;,
                 table_name, mem_ttl, mag_ttl)
    except client.exceptions.ConflictException:
        # Table exists on database [{database}]. Skipping table creation&#34;
        log.debug(&#34;Table [%s] exists. Skipping database creation.&#34;, table_name)


def _update_table(client: BaseClient,
                  database: str,
                  table_name: str,
                  mem_ttl: int,
                  mag_ttl: int) -&gt; None:
    client.update_table(DatabaseName=database,
                        TableName=table_name,
                        RetentionProperties={
                            &#39;MemoryStoreRetentionPeriodInHours&#39;: mem_ttl,
                            &#39;MagneticStoreRetentionPeriodInDays&#39;: mag_ttl
                        })
    log.info(&#34;Retention updated to %sh and %sd.&#34;, mem_ttl, mag_ttl)


def _delete_table(client: BaseClient,
                  database: str,
                  table_name: str) -&gt; None:
    try:
        client.delete_table(DatabaseName=database, TableName=table_name)
    except client.exceptions.ResourceNotFoundException:
        pass  # Ignore


# noinspection PyUnusedLocal
class Provider(DBProvider):
    &#34;&#34;&#34;
    Expose an Haystack data via the Haystack Rest API and SQL+TS databases
    &#34;&#34;&#34;
    __slots__ = &#34;_parsed_ts&#34;, &#34;_ts_table_name&#34;, &#34;_ts_database_name&#34;, &#34;_boto&#34;, &#34;_write_client&#34;, &#34;_read_client&#34;

    @property
    def name(self) -&gt; str:
        return &#34;SQL+timeseries&#34;

    def __init__(self, envs: Dict[str, str]):
        super().__init__(envs)
        log.info(&#34;Use %s&#34;, self._get_ts())
        self._parsed_ts = urlparse(self._get_ts())
        self._ts_table_name = self._parsed_ts.fragment
        if not self._ts_table_name:
            self._ts_table_name = &#34;haystack&#34;
        self._ts_database_name = self._parsed_ts.hostname
        self._boto = None
        self._write_client = None
        self._read_client = None

    def _get_boto(self):
        if not self._boto:
            self._boto = boto3.Session()
        return self._boto

    def _get_ts(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Return the url to the file to expose. &#34;&#34;&#34;
        return self._envs[&#34;HAYSTACK_TS&#34;]

    def _get_write_client(self):
        if not self._write_client:
            region = self._envs.get(&#34;AWS_REGION&#34;,
                                    self._envs.get(&#34;AWS_DEFAULT_REGION&#34;))
            self._write_client = self._get_boto().client(&#39;timestream-write&#39;,
                                                         region_name=region,
                                                         config=Config(read_timeout=10,
                                                                       max_pool_connections=5000,
                                                                       retries={&#39;max_attempts&#39;: 3},
                                                                       region_name=self._envs[&#34;AWS_REGION&#34;],
                                                                       )
                                                         )
        return self._write_client

    def _get_read_client(self):
        if not self._read_client:
            region = self._envs.get(&#34;AWS_REGION&#34;,
                                    self._envs.get(&#34;AWS_DEFAULT_REGION&#34;))
            self._read_client = self._get_boto().client(&#39;timestream-query&#39;,
                                                        region_name=region)
        return self._read_client

    # @overrides
    def _import_ts_in_db(self, time_series: Grid,
                         entity_id: Ref,
                         customer_id: Optional[str],
                         now: Optional[datetime] = None
                         ) -&gt; None:
        client = self._get_write_client()
        try:
            if not time_series:
                return  # Empty
            value = time_series[0][&#34;val&#34;]  # Suppose all values share the same type
            cast_fn, target_type = Provider._hs_to_timestream_type(value)
            if not customer_id:  # Empty string ?
                customer_id = &#39; &#39;
            common_attributs = {
                &#39;Dimensions&#39;: list(filter(lambda x: x[&#39;Value&#39;] is not None, [
                    {&#39;Name&#39;: &#39;id&#39;, &#39;Value&#39;: entity_id.name},
                    {&#39;Name&#39;: &#39;hs_type&#39;, &#39;Value&#39;: type(value).__name__},
                    {&#39;Name&#39;: &#39;unit&#39;, &#39;Value&#39;: value.symbol if isinstance(value, Quantity) else &#34; &#34;},
                    {&#39;Name&#39;: &#39;customer_id&#39;, &#39;Value&#39;: customer_id}
                ])),
                &#39;MeasureName&#39;: &#39;val&#39;,
                &#39;MeasureValueType&#39;: target_type,  # DOUBLE | BIGINT | VARCHAR | BOOLEAN
                &#39;TimeUnit&#39;: &#39;MICROSECONDS&#39;,  # MILLISECONDS | SECONDS | MICROSECONDS | NANOSECONDS
                &#39;Version&#39;: int(round(datetime.now().timestamp() * 1000000))
            }

            records = [{
                &#39;Time&#39;: str(int(round(row[&#34;ts&#34;].timestamp() * 1000000))),
                &#34;MeasureValue&#34;: cast_fn(row[&#34;val&#34;]),
            } for row in time_series]

            for i in range(0, len(records), _MAX_ROWS_BY_WRITE):
                result = client.write_records(DatabaseName=self._ts_database_name,
                                              TableName=self._ts_table_name,
                                              Records=records[i:i + _MAX_ROWS_BY_WRITE],
                                              CommonAttributes=common_attributs)
                log.debug(&#34;WriteRecords Status: [%s]&#34;, result[&#39;ResponseMetadata&#39;][&#39;HTTPStatusCode&#39;])
        except client.exceptions.RejectedRecordsException as err:
            log.error(&#34;RejectedRecords: %s&#34;, err)
            for rejected_record in err.response[&#34;RejectedRecords&#34;]:
                log.error(&#39; [%s:%s]: %s&#39;,
                          str(rejected_record[&#34;RecordIndex&#34;]),
                          time_series[rejected_record[&#34;RecordIndex&#34;]][&#34;ts&#34;],
                          rejected_record[&#34;Reason&#34;]
                          )
            raise

    @staticmethod
    def _hs_to_timestream_type(value: Any) -&gt; Tuple[Callable, str]:
        cast_fn = str
        if isinstance(value, str):
            target_type = &#34;VARCHAR&#34;
        elif isinstance(value, float):
            target_type = &#34;DOUBLE&#34;
        elif isinstance(value, Quantity):
            target_type = &#34;DOUBLE&#34;
            cast_fn = lambda x: str(x.m)
        elif isinstance(value, bool):
            target_type = &#34;BOOLEAN&#34;
        elif isinstance(value, int):
            target_type = &#34;DOUBLE&#34;
        elif value is MARKER:
            target_type = &#34;BOOLEAN&#34;
            cast_fn = lambda x: str(x is MARKER)
        elif value is REMOVE:
            target_type = &#34;BOOLEAN&#34;
            cast_fn = lambda x: str(x is REMOVE)
        elif value is NA:
            target_type = &#39;BOOLEAN&#39;
            cast_fn = lambda x: str(x is NA)
        elif isinstance(value, Ref):
            target_type = &#34;VARCHAR&#34;
            cast_fn = lambda x: x.name
        elif isinstance(value, datetime):
            target_type = &#34;BIGINT&#34;
            cast_fn = lambda x: str(int(round(x.timestamp())))
        elif isinstance(value, date):
            target_type = &#34;BIGINT&#34;
            cast_fn = lambda x: str(x.toordinal())
        elif isinstance(value, time):
            target_type = &#34;BIGINT&#34;
            cast_fn = lambda x: str(((x.hour * 60 + x.minute) * 60 + x.second) * 1000000 + x.microsecond)
        elif isinstance(value, Coordinate):
            target_type = &#34;VARCHAR&#34;
            cast_fn = lambda x: str(x.latitude) + &#34;,&#34; + str(x.longitude)
        elif isinstance(value, XStr):
            target_type = &#34;VARCHAR&#34;
            cast_fn = lambda x: value.encoding + &#34;,&#34; + value.data_to_string()
        elif value is None:
            target_type = &#34;BOOLEAN&#34;
            cast_fn = lambda x: str(False)
        else:
            raise ValueError(&#34;Unknwon type&#34;)
        return cast_fn, target_type

    @staticmethod
    def _cast_timeserie_to_hs(val: str,
                              python_type: str,
                              unit: str) -&gt; Any:
        if python_type == &#34;str&#34;:
            return val
        if python_type == &#34;float&#34;:
            return float(val)
        if python_type == &#34;_PintQuantity&#34;:
            return Quantity(float(val), unit)
        if python_type == &#34;Quantity&#34;:
            return Quantity(float(val), unit)
        if python_type == &#34;bool&#34;:
            return val.lower() == &#39;true&#39;
        if python_type == &#34;int&#34;:
            return int(float(val))
        if python_type == &#34;_MarkerType&#34;:
            return MARKER if val else None
        if python_type == &#34;_RemoveType&#34;:
            return REMOVE if val else None
        if python_type == &#34;_NAType&#34;:
            return NA if val else None
        if python_type == &#34;Ref&#34;:
            return Ref(val)
        if python_type == &#34;datetime&#34;:
            return datetime.fromtimestamp(int(val))
        if python_type == &#34;date&#34;:
            return date.fromordinal(int(val))
        if python_type == &#34;time&#34;:
            int_time = int(val)
            hour = ((int_time // 1000000) // 60) // 60
            minute = ((int_time // 1000000) // 60) % 60
            split = (int_time // 1000000) % 60
            mic = int_time % 1000000
            return time(hour, minute, split, mic)
        if python_type == &#34;Coordinate&#34;:
            split = val.split(&#34;,&#34;)
            return Coordinate(float(split[0]), float(split[1]))
        if python_type == &#34;XStr&#34;:
            split = val.split(&#34;,&#34;)
            return XStr(*split)
        if python_type == &#34;NoneType&#34;:
            return None
        raise ValueError(f&#34;Unknown type {python_type}&#34;)

    _kind_type = {
        &#34;marker&#34;: &#34;BOOLEAN&#34;,
        &#34;delete&#34;: &#34;BOOLEAN&#34;,
        &#34;bool&#34;: &#34;BOOLEAN&#34;,
        &#34;na&#34;: &#34;BOOLEAN&#34;,
        &#34;number&#34;: &#34;DOUBLE&#34;,
        &#34;remove&#34;: &#34;BOOLEAN&#34;,
        &#34;str&#34;: &#34;VARCHAR&#34;,
        &#34;uri&#34;: &#34;VARCHAR&#34;,
        &#34;ref&#34;: &#34;VARCHAR&#34;,
        &#34;date&#34;: &#34;BIGINT&#34;,
        &#34;time&#34;: &#34;BIGINT&#34;,
        &#34;datetime&#34;: &#34;BIGINT&#34;,
        &#34;coord&#34;: &#34;VARCHAR&#34;,
        &#34;xstr&#34;: &#34;VARCHAR&#34;,
    }

    @staticmethod
    def _kind_to_timestream_type(kind: str) -&gt; str:
        return Provider._kind_type[kind.lower()]

    @overrides
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Optional[Tuple[datetime, datetime]] = None,
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:
        paginator = self._get_read_client().get_paginator(&#39;query&#39;)
        # To deduce the target type, read the haystack entity
        entity = self.read(1, None, [entity_id], None, date_version)[0]
        if not entity:
            raise ValueError(f&#34; id &#39;{entity_id} not found&#34;)

        if not date_version:
            date_version = datetime.max.replace(tzinfo=pytz.UTC)
        if dates_range and dates_range[1] &gt; date_version:
            dates_range = list(dates_range)
            dates_range[1] = date_version

        kind = entity.get(&#34;kind&#34;, &#34;Number&#34;)
        timestream_type = Provider._kind_to_timestream_type(kind)
        customer_id = self.get_customer_id()
        if not customer_id:
            customer_id = &#39; &#39;
        try:
            history = Grid(columns=[&#34;ts&#34;, &#34;val&#34;])

            select_all = f&#34;SELECT time,hs_type,unit,measure_value::{timestream_type} &#34; \
                         f&#34;FROM {self._ts_database_name}.{self._ts_table_name} &#34; \
                         f&#34;WHERE id=&#39;{entity_id.name}&#39; AND customer_id=&#39;{customer_id}&#39; &#34;
            if dates_range:
                select_all += f&#34;AND time BETWEEN from_iso8601_timestamp(&#39;{dates_range[0].isoformat()}&#39;) &#34; \
                              f&#34;AND from_iso8601_timestamp(&#39;{dates_range[1].isoformat()}&#39;)&#34;
            page_iterator = paginator.paginate(QueryString=select_all)
            for page in page_iterator:

                for row in page[&#39;Rows&#39;]:
                    datas = row[&#39;Data&#39;]
                    # noinspection PyUnresolvedReferences
                    scalar_value = dateutil.parser.isoparse(datas[0][&#39;ScalarValue&#39;])
                    if not scalar_value.tzname():
                        scalar_value = scalar_value.replace(tzinfo=pytz.UTC)
                    hs_type = datas[1][&#39;ScalarValue&#39;]
                    unit = datas[2][&#39;ScalarValue&#39;].strip()
                    str_val = datas[3][&#39;ScalarValue&#39;]
                    if not hs_type:
                        hs_type = &#34;float&#34;
                    history.append({&#34;ts&#34;: scalar_value,
                                    &#34;val&#34;: Provider._cast_timeserie_to_hs(str_val, hs_type, unit)})

            if history:
                min_date = datetime.max.replace(tzinfo=pytz.UTC)
                max_date = datetime.min.replace(tzinfo=pytz.UTC)

                for time_serie in history:
                    min_date = min(min_date, time_serie[&#34;ts&#34;])
                    max_date = max(max_date, time_serie[&#34;ts&#34;])
            else:
                min_date = date_version
                max_date = date_version

            history.metadata = {
                &#34;id&#34;: entity_id,
                &#34;hisStart&#34;: min_date,
                &#34;hisEnd&#34;: max_date,
            }
            return history
        except ValueError as err:
            log.error(&#34;Exception while running query: %s&#34;, err)
            raise

    def create_ts(self) -&gt; None:
        &#34;&#34;&#34; Create the time serie database and schema. &#34;&#34;&#34;
        client = self._get_write_client()
        _create_database(client, self._ts_database_name)
        pqs = parse_qs(self._parsed_ts.query)
        mem_ttl = int(pqs[&#34;mem_ttl&#34;][0]) if &#34;mem_ttl&#34; in pqs else _DEFAULT_MEM_TTL
        mag_ttl = int(pqs[&#34;mag_ttl&#34;][0]) if &#34;mag_ttl&#34; in pqs else _DEFAULT_MAG_TTL
        _create_table(client, self._ts_database_name, self._ts_table_name, mem_ttl, mag_ttl)

    def purge_ts(self) -&gt; None:
        &#34;&#34;&#34; Purge the timeserie database. &#34;&#34;&#34;
        _delete_table(self._get_write_client(), self._ts_database_name, self._ts_table_name)

    @overrides
    def create_db(self) -&gt; None:
        super().create_db()
        self.create_ts()

    @overrides
    def purge_db(self) -&gt; None:
        super().purge_db()
        self.purge_ts()

    @overrides
    def import_ts(self,
                  source_uri: str,
                  customer_id: str = &#39;&#39;,
                  version: Optional[datetime] = None
                  ):
        target_grid = read_grid_from_uri(source_uri, envs=self._envs)
        dir_name = dirname(source_uri)
        if not version:
            version = datetime.now(tz=pytz.UTC)

        for row in target_grid:
            if &#34;hisURI&#34; in row:
                assert &#34;id&#34; in row, &#34;TS must have an id&#34;
                uri = dir_name + &#39;/&#39; + row[&#39;hisURI&#39;]
                ts_grid = read_grid_from_uri(uri, envs=self._envs)
                self._import_ts_in_db(ts_grid, row[&#34;id&#34;], customer_id, version)
                log.info(&#34;%s imported&#34;, uri)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shaystack.providers.timestream.Provider"><code class="flex name class">
<span>class <span class="ident">Provider</span></span>
<span>(</span><span>envs: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Expose an Haystack data via the Haystack Rest API and SQL+TS databases</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Provider(DBProvider):
    &#34;&#34;&#34;
    Expose an Haystack data via the Haystack Rest API and SQL+TS databases
    &#34;&#34;&#34;
    __slots__ = &#34;_parsed_ts&#34;, &#34;_ts_table_name&#34;, &#34;_ts_database_name&#34;, &#34;_boto&#34;, &#34;_write_client&#34;, &#34;_read_client&#34;

    @property
    def name(self) -&gt; str:
        return &#34;SQL+timeseries&#34;

    def __init__(self, envs: Dict[str, str]):
        super().__init__(envs)
        log.info(&#34;Use %s&#34;, self._get_ts())
        self._parsed_ts = urlparse(self._get_ts())
        self._ts_table_name = self._parsed_ts.fragment
        if not self._ts_table_name:
            self._ts_table_name = &#34;haystack&#34;
        self._ts_database_name = self._parsed_ts.hostname
        self._boto = None
        self._write_client = None
        self._read_client = None

    def _get_boto(self):
        if not self._boto:
            self._boto = boto3.Session()
        return self._boto

    def _get_ts(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Return the url to the file to expose. &#34;&#34;&#34;
        return self._envs[&#34;HAYSTACK_TS&#34;]

    def _get_write_client(self):
        if not self._write_client:
            region = self._envs.get(&#34;AWS_REGION&#34;,
                                    self._envs.get(&#34;AWS_DEFAULT_REGION&#34;))
            self._write_client = self._get_boto().client(&#39;timestream-write&#39;,
                                                         region_name=region,
                                                         config=Config(read_timeout=10,
                                                                       max_pool_connections=5000,
                                                                       retries={&#39;max_attempts&#39;: 3},
                                                                       region_name=self._envs[&#34;AWS_REGION&#34;],
                                                                       )
                                                         )
        return self._write_client

    def _get_read_client(self):
        if not self._read_client:
            region = self._envs.get(&#34;AWS_REGION&#34;,
                                    self._envs.get(&#34;AWS_DEFAULT_REGION&#34;))
            self._read_client = self._get_boto().client(&#39;timestream-query&#39;,
                                                        region_name=region)
        return self._read_client

    # @overrides
    def _import_ts_in_db(self, time_series: Grid,
                         entity_id: Ref,
                         customer_id: Optional[str],
                         now: Optional[datetime] = None
                         ) -&gt; None:
        client = self._get_write_client()
        try:
            if not time_series:
                return  # Empty
            value = time_series[0][&#34;val&#34;]  # Suppose all values share the same type
            cast_fn, target_type = Provider._hs_to_timestream_type(value)
            if not customer_id:  # Empty string ?
                customer_id = &#39; &#39;
            common_attributs = {
                &#39;Dimensions&#39;: list(filter(lambda x: x[&#39;Value&#39;] is not None, [
                    {&#39;Name&#39;: &#39;id&#39;, &#39;Value&#39;: entity_id.name},
                    {&#39;Name&#39;: &#39;hs_type&#39;, &#39;Value&#39;: type(value).__name__},
                    {&#39;Name&#39;: &#39;unit&#39;, &#39;Value&#39;: value.symbol if isinstance(value, Quantity) else &#34; &#34;},
                    {&#39;Name&#39;: &#39;customer_id&#39;, &#39;Value&#39;: customer_id}
                ])),
                &#39;MeasureName&#39;: &#39;val&#39;,
                &#39;MeasureValueType&#39;: target_type,  # DOUBLE | BIGINT | VARCHAR | BOOLEAN
                &#39;TimeUnit&#39;: &#39;MICROSECONDS&#39;,  # MILLISECONDS | SECONDS | MICROSECONDS | NANOSECONDS
                &#39;Version&#39;: int(round(datetime.now().timestamp() * 1000000))
            }

            records = [{
                &#39;Time&#39;: str(int(round(row[&#34;ts&#34;].timestamp() * 1000000))),
                &#34;MeasureValue&#34;: cast_fn(row[&#34;val&#34;]),
            } for row in time_series]

            for i in range(0, len(records), _MAX_ROWS_BY_WRITE):
                result = client.write_records(DatabaseName=self._ts_database_name,
                                              TableName=self._ts_table_name,
                                              Records=records[i:i + _MAX_ROWS_BY_WRITE],
                                              CommonAttributes=common_attributs)
                log.debug(&#34;WriteRecords Status: [%s]&#34;, result[&#39;ResponseMetadata&#39;][&#39;HTTPStatusCode&#39;])
        except client.exceptions.RejectedRecordsException as err:
            log.error(&#34;RejectedRecords: %s&#34;, err)
            for rejected_record in err.response[&#34;RejectedRecords&#34;]:
                log.error(&#39; [%s:%s]: %s&#39;,
                          str(rejected_record[&#34;RecordIndex&#34;]),
                          time_series[rejected_record[&#34;RecordIndex&#34;]][&#34;ts&#34;],
                          rejected_record[&#34;Reason&#34;]
                          )
            raise

    @staticmethod
    def _hs_to_timestream_type(value: Any) -&gt; Tuple[Callable, str]:
        cast_fn = str
        if isinstance(value, str):
            target_type = &#34;VARCHAR&#34;
        elif isinstance(value, float):
            target_type = &#34;DOUBLE&#34;
        elif isinstance(value, Quantity):
            target_type = &#34;DOUBLE&#34;
            cast_fn = lambda x: str(x.m)
        elif isinstance(value, bool):
            target_type = &#34;BOOLEAN&#34;
        elif isinstance(value, int):
            target_type = &#34;DOUBLE&#34;
        elif value is MARKER:
            target_type = &#34;BOOLEAN&#34;
            cast_fn = lambda x: str(x is MARKER)
        elif value is REMOVE:
            target_type = &#34;BOOLEAN&#34;
            cast_fn = lambda x: str(x is REMOVE)
        elif value is NA:
            target_type = &#39;BOOLEAN&#39;
            cast_fn = lambda x: str(x is NA)
        elif isinstance(value, Ref):
            target_type = &#34;VARCHAR&#34;
            cast_fn = lambda x: x.name
        elif isinstance(value, datetime):
            target_type = &#34;BIGINT&#34;
            cast_fn = lambda x: str(int(round(x.timestamp())))
        elif isinstance(value, date):
            target_type = &#34;BIGINT&#34;
            cast_fn = lambda x: str(x.toordinal())
        elif isinstance(value, time):
            target_type = &#34;BIGINT&#34;
            cast_fn = lambda x: str(((x.hour * 60 + x.minute) * 60 + x.second) * 1000000 + x.microsecond)
        elif isinstance(value, Coordinate):
            target_type = &#34;VARCHAR&#34;
            cast_fn = lambda x: str(x.latitude) + &#34;,&#34; + str(x.longitude)
        elif isinstance(value, XStr):
            target_type = &#34;VARCHAR&#34;
            cast_fn = lambda x: value.encoding + &#34;,&#34; + value.data_to_string()
        elif value is None:
            target_type = &#34;BOOLEAN&#34;
            cast_fn = lambda x: str(False)
        else:
            raise ValueError(&#34;Unknwon type&#34;)
        return cast_fn, target_type

    @staticmethod
    def _cast_timeserie_to_hs(val: str,
                              python_type: str,
                              unit: str) -&gt; Any:
        if python_type == &#34;str&#34;:
            return val
        if python_type == &#34;float&#34;:
            return float(val)
        if python_type == &#34;_PintQuantity&#34;:
            return Quantity(float(val), unit)
        if python_type == &#34;Quantity&#34;:
            return Quantity(float(val), unit)
        if python_type == &#34;bool&#34;:
            return val.lower() == &#39;true&#39;
        if python_type == &#34;int&#34;:
            return int(float(val))
        if python_type == &#34;_MarkerType&#34;:
            return MARKER if val else None
        if python_type == &#34;_RemoveType&#34;:
            return REMOVE if val else None
        if python_type == &#34;_NAType&#34;:
            return NA if val else None
        if python_type == &#34;Ref&#34;:
            return Ref(val)
        if python_type == &#34;datetime&#34;:
            return datetime.fromtimestamp(int(val))
        if python_type == &#34;date&#34;:
            return date.fromordinal(int(val))
        if python_type == &#34;time&#34;:
            int_time = int(val)
            hour = ((int_time // 1000000) // 60) // 60
            minute = ((int_time // 1000000) // 60) % 60
            split = (int_time // 1000000) % 60
            mic = int_time % 1000000
            return time(hour, minute, split, mic)
        if python_type == &#34;Coordinate&#34;:
            split = val.split(&#34;,&#34;)
            return Coordinate(float(split[0]), float(split[1]))
        if python_type == &#34;XStr&#34;:
            split = val.split(&#34;,&#34;)
            return XStr(*split)
        if python_type == &#34;NoneType&#34;:
            return None
        raise ValueError(f&#34;Unknown type {python_type}&#34;)

    _kind_type = {
        &#34;marker&#34;: &#34;BOOLEAN&#34;,
        &#34;delete&#34;: &#34;BOOLEAN&#34;,
        &#34;bool&#34;: &#34;BOOLEAN&#34;,
        &#34;na&#34;: &#34;BOOLEAN&#34;,
        &#34;number&#34;: &#34;DOUBLE&#34;,
        &#34;remove&#34;: &#34;BOOLEAN&#34;,
        &#34;str&#34;: &#34;VARCHAR&#34;,
        &#34;uri&#34;: &#34;VARCHAR&#34;,
        &#34;ref&#34;: &#34;VARCHAR&#34;,
        &#34;date&#34;: &#34;BIGINT&#34;,
        &#34;time&#34;: &#34;BIGINT&#34;,
        &#34;datetime&#34;: &#34;BIGINT&#34;,
        &#34;coord&#34;: &#34;VARCHAR&#34;,
        &#34;xstr&#34;: &#34;VARCHAR&#34;,
    }

    @staticmethod
    def _kind_to_timestream_type(kind: str) -&gt; str:
        return Provider._kind_type[kind.lower()]

    @overrides
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Optional[Tuple[datetime, datetime]] = None,
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:
        paginator = self._get_read_client().get_paginator(&#39;query&#39;)
        # To deduce the target type, read the haystack entity
        entity = self.read(1, None, [entity_id], None, date_version)[0]
        if not entity:
            raise ValueError(f&#34; id &#39;{entity_id} not found&#34;)

        if not date_version:
            date_version = datetime.max.replace(tzinfo=pytz.UTC)
        if dates_range and dates_range[1] &gt; date_version:
            dates_range = list(dates_range)
            dates_range[1] = date_version

        kind = entity.get(&#34;kind&#34;, &#34;Number&#34;)
        timestream_type = Provider._kind_to_timestream_type(kind)
        customer_id = self.get_customer_id()
        if not customer_id:
            customer_id = &#39; &#39;
        try:
            history = Grid(columns=[&#34;ts&#34;, &#34;val&#34;])

            select_all = f&#34;SELECT time,hs_type,unit,measure_value::{timestream_type} &#34; \
                         f&#34;FROM {self._ts_database_name}.{self._ts_table_name} &#34; \
                         f&#34;WHERE id=&#39;{entity_id.name}&#39; AND customer_id=&#39;{customer_id}&#39; &#34;
            if dates_range:
                select_all += f&#34;AND time BETWEEN from_iso8601_timestamp(&#39;{dates_range[0].isoformat()}&#39;) &#34; \
                              f&#34;AND from_iso8601_timestamp(&#39;{dates_range[1].isoformat()}&#39;)&#34;
            page_iterator = paginator.paginate(QueryString=select_all)
            for page in page_iterator:

                for row in page[&#39;Rows&#39;]:
                    datas = row[&#39;Data&#39;]
                    # noinspection PyUnresolvedReferences
                    scalar_value = dateutil.parser.isoparse(datas[0][&#39;ScalarValue&#39;])
                    if not scalar_value.tzname():
                        scalar_value = scalar_value.replace(tzinfo=pytz.UTC)
                    hs_type = datas[1][&#39;ScalarValue&#39;]
                    unit = datas[2][&#39;ScalarValue&#39;].strip()
                    str_val = datas[3][&#39;ScalarValue&#39;]
                    if not hs_type:
                        hs_type = &#34;float&#34;
                    history.append({&#34;ts&#34;: scalar_value,
                                    &#34;val&#34;: Provider._cast_timeserie_to_hs(str_val, hs_type, unit)})

            if history:
                min_date = datetime.max.replace(tzinfo=pytz.UTC)
                max_date = datetime.min.replace(tzinfo=pytz.UTC)

                for time_serie in history:
                    min_date = min(min_date, time_serie[&#34;ts&#34;])
                    max_date = max(max_date, time_serie[&#34;ts&#34;])
            else:
                min_date = date_version
                max_date = date_version

            history.metadata = {
                &#34;id&#34;: entity_id,
                &#34;hisStart&#34;: min_date,
                &#34;hisEnd&#34;: max_date,
            }
            return history
        except ValueError as err:
            log.error(&#34;Exception while running query: %s&#34;, err)
            raise

    def create_ts(self) -&gt; None:
        &#34;&#34;&#34; Create the time serie database and schema. &#34;&#34;&#34;
        client = self._get_write_client()
        _create_database(client, self._ts_database_name)
        pqs = parse_qs(self._parsed_ts.query)
        mem_ttl = int(pqs[&#34;mem_ttl&#34;][0]) if &#34;mem_ttl&#34; in pqs else _DEFAULT_MEM_TTL
        mag_ttl = int(pqs[&#34;mag_ttl&#34;][0]) if &#34;mag_ttl&#34; in pqs else _DEFAULT_MAG_TTL
        _create_table(client, self._ts_database_name, self._ts_table_name, mem_ttl, mag_ttl)

    def purge_ts(self) -&gt; None:
        &#34;&#34;&#34; Purge the timeserie database. &#34;&#34;&#34;
        _delete_table(self._get_write_client(), self._ts_database_name, self._ts_table_name)

    @overrides
    def create_db(self) -&gt; None:
        super().create_db()
        self.create_ts()

    @overrides
    def purge_db(self) -&gt; None:
        super().purge_db()
        self.purge_ts()

    @overrides
    def import_ts(self,
                  source_uri: str,
                  customer_id: str = &#39;&#39;,
                  version: Optional[datetime] = None
                  ):
        target_grid = read_grid_from_uri(source_uri, envs=self._envs)
        dir_name = dirname(source_uri)
        if not version:
            version = datetime.now(tz=pytz.UTC)

        for row in target_grid:
            if &#34;hisURI&#34; in row:
                assert &#34;id&#34; in row, &#34;TS must have an id&#34;
                uri = dir_name + &#39;/&#39; + row[&#39;hisURI&#39;]
                ts_grid = read_grid_from_uri(uri, envs=self._envs)
                self._import_ts_in_db(ts_grid, row[&#34;id&#34;], customer_id, version)
                log.info(&#34;%s imported&#34;, uri)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="shaystack.providers.db.Provider" href="db.html#shaystack.providers.db.Provider">Provider</a></li>
<li><a title="shaystack.providers.db_haystack_interface.DBHaystackInterface" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface">DBHaystackInterface</a></li>
<li><a title="shaystack.providers.haystack_interface.HaystackInterface" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface">HaystackInterface</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="shaystack.providers.timestream.Provider.create_ts"><code class="name flex">
<span>def <span class="ident">create_ts</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Create the time serie database and schema.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_ts(self) -&gt; None:
    &#34;&#34;&#34; Create the time serie database and schema. &#34;&#34;&#34;
    client = self._get_write_client()
    _create_database(client, self._ts_database_name)
    pqs = parse_qs(self._parsed_ts.query)
    mem_ttl = int(pqs[&#34;mem_ttl&#34;][0]) if &#34;mem_ttl&#34; in pqs else _DEFAULT_MEM_TTL
    mag_ttl = int(pqs[&#34;mag_ttl&#34;][0]) if &#34;mag_ttl&#34; in pqs else _DEFAULT_MAG_TTL
    _create_table(client, self._ts_database_name, self._ts_table_name, mem_ttl, mag_ttl)</code></pre>
</details>
</dd>
<dt id="shaystack.providers.timestream.Provider.purge_ts"><code class="name flex">
<span>def <span class="ident">purge_ts</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Purge the timeserie database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge_ts(self) -&gt; None:
    &#34;&#34;&#34; Purge the timeserie database. &#34;&#34;&#34;
    _delete_table(self._get_write_client(), self._ts_database_name, self._ts_table_name)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="shaystack.providers.db.Provider" href="db.html#shaystack.providers.db.Provider">Provider</a></b></code>:
<ul class="hlist">
<li><code><a title="shaystack.providers.db.Provider.about" href="db.html#shaystack.providers.db.Provider.about">about</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.create_db" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.create_db">create_db</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.formats" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.formats">formats</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.get_customer_id" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.get_customer_id">get_customer_id</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.get_tz" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.get_tz">get_tz</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.his_read" href="db.html#shaystack.providers.db.Provider.his_read">his_read</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.his_write" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.his_write">his_write</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.import_data" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.import_data">import_data</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.import_ts" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.import_ts">import_ts</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.invoke_action" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.invoke_action">invoke_action</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.name" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.name">name</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.nav" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.nav">nav</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.ops" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.ops">ops</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.point_write_read" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.point_write_read">point_write_read</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.point_write_write" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.point_write_write">point_write_write</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.purge_db" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.purge_db">purge_db</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.read" href="db.html#shaystack.providers.db.Provider.read">read</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.read_grid" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.read_grid">read_grid</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.update_grid" href="db_haystack_interface.html#shaystack.providers.db_haystack_interface.DBHaystackInterface.update_grid">update_grid</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.values_for_tag" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.values_for_tag">values_for_tag</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.versions" href="db.html#shaystack.providers.db.Provider.versions">versions</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.watch_poll" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.watch_poll">watch_poll</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.watch_sub" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.watch_sub">watch_sub</a></code></li>
<li><code><a title="shaystack.providers.db.Provider.watch_unsub" href="haystack_interface.html#shaystack.providers.haystack_interface.HaystackInterface.watch_unsub">watch_unsub</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shaystack.providers" href="index.html">shaystack.providers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shaystack.providers.timestream.Provider" href="#shaystack.providers.timestream.Provider">Provider</a></code></h4>
<ul class="">
<li><code><a title="shaystack.providers.timestream.Provider.create_ts" href="#shaystack.providers.timestream.Provider.create_ts">create_ts</a></code></li>
<li><code><a title="shaystack.providers.timestream.Provider.purge_ts" href="#shaystack.providers.timestream.Provider.purge_ts">purge_ts</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>